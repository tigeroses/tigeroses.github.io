<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tigerose&#39;s site</title>
  
  <subtitle>In me the tiger sniffs the rose</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-25T08:56:39.481Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tigerose</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>doctest单元测试库</title>
    <link href="http://yoursite.com/2021/07/25/doctest/"/>
    <id>http://yoursite.com/2021/07/25/doctest/</id>
    <published>2021-07-25T08:41:39.000Z</published>
    <updated>2021-07-25T08:56:39.481Z</updated>
    
    <content type="html"><![CDATA[<p>doctest是一个C++单元测试库,代码仓库地址: <a href="https://github.com/onqtam/doctest" target="_blank" rel="noopener">https://github.com/onqtam/doctest</a>, 本文内容主要来自官方文档与项目实践</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>header-only</li><li>fast</li><li>thread-safe</li></ul><h2 id="断言宏"><a href="#断言宏" class="headerlink" title="断言宏"></a>断言宏</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>三个level,严重程度依次降低:</p><ul><li>REQUIRE. 断言失败立即退出用例</li><li>CHECK. 断言失败继续执行用例</li><li>WARN. 打印信息,而不标记失败</li></ul><p>例子: <code>CHECK(flags == state::alive | state::moving);</code>  </p><p>其他的宏都可以认为是三个基本宏扩展来的,以下的 LEVEL 可替换为 REQUIRE/CHECK/WARN 中的任一个</p><p>否定断言:LEVEL_FALSE(exp)</p><p>输出信息:LEVEL_MESSAGE(exp, message)<br>例子: <code>CHECK_MESSAGE(a &lt; b, &quot;relevant only to this assert &quot; &lt;&lt; other_local &lt;&lt; &quot;more text!&quot;);</code></p><h3 id="二元与一元"><a href="#二元与一元" class="headerlink" title="二元与一元"></a>二元与一元</h3><p>二元断言,接受两个参数(left, right):</p><ul><li>LEVEL_EQ ==</li><li>LEVEL_NE !+</li><li>LEVEL_GT &gt;</li><li>LEVEL_LT &lt;</li><li>LEVEL_GE &gt;=</li><li>LEVEL_LE &lt;=</li></ul><p>一元断言,接受一个表达式:</p><ul><li>LEVEL_UNARY 等价于 LEVEL</li><li>LEVEL_UNARY_FALSE 等价于 LEVEL_FALSE</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>LEVEL_THROWS(exp) 期待表达式抛出异常</li><li>LEVEL_THROWS_AS(exp, exp_type) 指定异常类型<br>  <code>CHECK_THROWS_AS(func(), std::exception);</code></li><li>LEVEL_THROWS_WITH(exp, c_str) 异常信息可以转换为字符串<br>  <code>CHECK_THROWS_WITH(func(), &quot;invalid operation!&quot;);</code></li><li>LEVEL_THROWS_WITH_AS(exp, c_str, exp_type) 异常信息与异常类型的结合</li><li>LEVEL_NOTHROW(exp) 期待无异常抛出</li></ul><p>每个异常断言都有_MESSAGE变种</p><h3 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h3><p>对浮点数采用容错比较</p><p><code>REQUIRE(22.0/7 == doctest::Approx(3.141).epsilon(0.01)); // allow for a 1% error</code></p><h2 id="TestCase"><a href="#TestCase" class="headerlink" title="TestCase"></a>TestCase</h2><p>使用的宏</p><ul><li>TEST_CASE(test name)</li><li>SUBCASE(subcase name)</li></ul><p>subcases不适用多线程,只能运行在主线程</p><p>对标 setup/teardown<br>同一level的subcase会顺序执行,且每次执行都会重复执行上层语句</p><h3 id="BDD-style"><a href="#BDD-style" class="headerlink" title="BDD-style"></a>BDD-style</h3><p>Behaviour Driven Development(行为驱动开发)</p><p>这里提供的接口与TEST_CASE/SUBCASE作用一样,通过testcase name来区分</p><ul><li>SCENARIO(scenario name) 情景,与TEST_CASE作用一致</li><li>SCENARIO_TEMPLATE(scenario name, type, list of types) 等价于TEST_CASE_TEMPLATE</li><li>SCENARIO_TEMPLATE_DEFINE(scenario name, type ,id) 等价于TEST_CASE_TEMPLATE_DEFINE</li><li>GIVEN(sth)</li><li>WHEN(sth)</li><li>THEN(sth)</li><li>AND_WHEN(sth)</li><li>AND_THEN(sth)</li></ul><h3 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h3><p>传统方式,可使用subcases 来替代</p><p>TEST_CASE_FIXTURE(class name, c_str)</p><p>先定义Fixture class,每一个test case会派生出唯一的类,可自由使用类成员与方法</p><h3 id="Test-Suites"><a href="#Test-Suites" class="headerlink" title="Test Suites"></a>Test Suites</h3><p>将test cases组合到一起就形成了test suites</p><p>使用TEST_SUITE() 或者TEST_SUITE_BEGIN()/TEST_SUITE_END()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST_SUITE(<span class="string">"math"</span>) &#123;</span><br><span class="line">    TEST_CASE(<span class="string">""</span>) &#123;&#125; <span class="comment">// part of the math test suite</span></span><br><span class="line">    TEST_CASE(<span class="string">""</span>) &#123;&#125; <span class="comment">// part of the math test suite</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST_SUITE_BEGIN(<span class="string">"utils"</span>);</span><br><span class="line">TEST_CASE(<span class="string">""</span>) &#123;&#125;</span><br><span class="line">TEST_SUITE_END();</span><br></pre></td></tr></table></figure><p>方便根据执行条件过滤</p><h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><p>装饰额外属性<br>可以用于TEST_CASE/TEST_SUITE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEST_CASE(<span class="string">"name"</span></span><br><span class="line">          * doctest::description(<span class="string">"shouldn't take more than 500ms"</span>)</span><br><span class="line">          * doctest::timeout(<span class="number">0.5</span>)) &#123;</span><br><span class="line">    <span class="comment">// asserts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有用的装饰:</p><ul><li>skip(bool = true) 跳过这个测试用例</li><li>may_fail(bool = true) 用于已知bug情况下记录追踪</li><li>timeout(double) 设置超时</li><li>description(“text”) 描述</li></ul><h2 id="参数化测试用例"><a href="#参数化测试用例" class="headerlink" title="参数化测试用例"></a>参数化测试用例</h2><p>此功能尚不完善</p><p>TEST_CASE_TEMPLATE 用于测试相同接口的不同实现是否满足一些共同的需求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEST_CASE_TEMPLATE(<span class="string">"signed integers stuff"</span>, T, <span class="keyword">char</span>, short, <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) &#123;</span><br><span class="line">    T var = T();</span><br><span class="line">    --var;</span><br><span class="line">    CHECK(var == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>可以用来过滤测试用例,使用通配符</p><ul><li>查询.<ul><li>-c 打印所有测试用例的个数</li><li>-ltc 打印所有测试用例</li><li>-lts 打印所有测试套件</li></ul></li><li>过滤. 灵活使用 */? 分别匹配多个和一个字符<ul><li>-tc= 过滤测试用例</li><li>-ts= 过滤测试套件</li><li>-sc= 过滤子用例</li><li>-tce= 排除某些测试用例</li></ul></li><li>其他.<ul><li>-o=filename 输出到文件,默认是到屏幕</li><li>-d=<bool> 打印每个测试用例的耗时,单位秒</li><li>-ns=<bool> 虽然代码标注了某些测试用例是跳过的,但是这里可以强制执行</li></ul></li></ul><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>一般可以通过在main.cpp中添加并只添加如下两行,来让doctest帮我们实现main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"doctest.h"</span></span></span><br></pre></td></tr></table></figure><p>也可以定义DOCTEST_CONFIG_IMPLEMENT并自定义main函数,用来配置属性,将测试框架集成进生产代码中等</p><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><h3 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h3><p>只有assert fails才打印信息,且需要把打印语句放到assert之前</p><p><code>INFO(&quot;The number is &quot;, i);</code> 旧版本用 <code>INFO(&quot;number &quot; &lt;&lt; 1);</code></p><p><code>CAPTURE(some_variable)</code> 封装INFO, 打印变量名称和值,形式如<code>some_variable := 42</code></p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>MESSAGE(message) 只打印信息,无关assert</p><p>FAIL(message) 人为制造失败的测试用例,结果如同REQUIRE失败,退出当前测试用例</p><p>FAIL_CHECK(message) 人为制造失败的测试用例,结果如同CHECK失败,继续执行当前测试用例</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>提供了许多配置宏</p><p>宏的定义必须早于头文件的引入;一次定义即可</p><p>选出几个比较重要的:</p><ul><li>DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN 自动生成main函数,要定义在源文件</li><li>DOCTEST_CONFIG_IMPLEMENT 用于自定义main</li><li>DOCTEST_CONFIG_DISABLE 从binary中移除单元测试,其独特性体现在可以在任何位置写测试代码而不用担心发布版本的性能</li><li>DOCTEST_CONFIG_SUPER_FAST_ASSERTS 加速断言</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>配置<code>DOCTEST_CONFIG_SUPER_FAST_ASSERTS</code> 加速断言的汇编过程</p><p>使用二元和一元断言速度比普通断言快</p><h2 id="其他测试相关"><a href="#其他测试相关" class="headerlink" title="其他测试相关"></a>其他测试相关</h2><p>Mock测试:主要作用是模拟一些在应用中不容易构造或者比较复杂的对象,从而把测试与测试边界以外的对象隔离开</p><h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><p>总结自examples</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断言</span></span><br><span class="line">REQUIRE(a == b); <span class="comment">//REQUIURE失败了会结束当前测试用例;比较整型,字符串,或自定义类型</span></span><br><span class="line">CHECK(doctest::Approx(<span class="number">0.502</span>) == <span class="number">0.501</span>); <span class="comment">//CHECK失败了继续执行;浮点数比较特殊处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test case</span></span><br><span class="line"><span class="comment">// 接受一个字符串来描述当前用例</span></span><br><span class="line">TEST_CASE(<span class="string">"expressions should be evaluated only once"</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    REQUIRE(++a == <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">LEVEL_THROWS(<span class="built_in">exp</span>); <span class="comment">// 期待表达式抛出异常</span></span><br><span class="line">CHECK_THROWS_AS(func(), <span class="built_in">std</span>::exception); <span class="comment">// 指定异常类型</span></span><br><span class="line">CHECK_THROWS_WITH(func(), <span class="string">"invalid operation!"</span>); <span class="comment">// 异常信息可以转换为字符串</span></span><br><span class="line">LEVEL_THROWS_WITH_AS(<span class="built_in">exp</span>, c_str, exp_type); <span class="comment">// 前两者的结合</span></span><br><span class="line">LEVEL_NOTHROW(<span class="built_in">exp</span>); <span class="comment">// 无异常抛出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息,提示测试了某某方法</span></span><br><span class="line">MESSAGE(<span class="string">"reached!"</span>);</span><br><span class="line">INFO(<span class="string">"lots of captures - some on heap: "</span> &lt;&lt; some_var);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子用例</span></span><br><span class="line">TEST_CASE(<span class="string">"test case should fail even though the last subcase passes"</span>) &#123;</span><br><span class="line">    SUBCASE(<span class="string">"one"</span>) &#123;</span><br><span class="line">        CHECK(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SUBCASE(<span class="string">"two"</span>) &#123;</span><br><span class="line">        CHECK(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情景测试</span></span><br><span class="line">SCENARIO(<span class="string">"vectors can be sized and resized"</span>) &#123;</span><br><span class="line">    GIVEN(<span class="string">"A vector with some items"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        REQUIRE(v.size() == <span class="number">5</span>);</span><br><span class="line">        REQUIRE(v.capacity() &gt;= <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        WHEN(<span class="string">"the size is increased"</span>) &#123;</span><br><span class="line">            v.resize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            THEN(<span class="string">"the size and capacity change"</span>) &#123;</span><br><span class="line">                CHECK(v.size() == <span class="number">20</span>);</span><br><span class="line">                CHECK(v.capacity() &gt;= <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        WHEN(<span class="string">"the size is reduced"</span>) &#123;</span><br><span class="line">            v.resize(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            THEN(<span class="string">"the size changes but not capacity"</span>) &#123;</span><br><span class="line">                CHECK(v.size() == <span class="number">0</span>);</span><br><span class="line">                CHECK(v.capacity() &gt;= <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板</span></span><br><span class="line"><span class="comment">// 一次测试多种类型</span></span><br><span class="line">TEST_CASE_TEMPLATE(<span class="string">"signed integers stuff"</span>, T, <span class="keyword">signed</span> <span class="keyword">char</span>, short, <span class="keyword">int</span>) &#123;</span><br><span class="line">    T var = T();</span><br><span class="line">    --var;</span><br><span class="line">    CHECK(var == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试套件</span></span><br><span class="line"><span class="comment">// 格式1</span></span><br><span class="line">TEST_SUITE(<span class="string">"scoped test suite"</span>) &#123;</span><br><span class="line">    TEST_CASE(<span class="string">"part of scoped"</span>) &#123;</span><br><span class="line">        FAIL(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TEST_CASE(<span class="string">"part of scoped 2"</span>) &#123;</span><br><span class="line">        FAIL(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 格式2</span></span><br><span class="line">TEST_SUITE_BEGIN(<span class="string">"some TS"</span>); <span class="comment">// begin "some TS"</span></span><br><span class="line">TEST_CASE(<span class="string">"part of some TS"</span>) &#123;</span><br><span class="line">    FAIL(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">TEST_SUITE_END(); <span class="comment">// ends "some TS"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚手架</span></span><br><span class="line"><span class="comment">// 构造和析构代替传统的setup()和teardown()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeFixture</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    SomeFixture() <span class="keyword">noexcept</span></span><br><span class="line">            : data(<span class="number">42</span>) &#123;</span><br><span class="line">        <span class="comment">// setup here</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~SomeFixture() &#123;</span><br><span class="line">        <span class="comment">// teardown here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TEST_CASE_FIXTURE(SomeFixture, <span class="string">"fixtured test - not part of a test suite"</span>) &#123;</span><br><span class="line">    data /= <span class="number">2</span>;</span><br><span class="line">    CHECK(data == <span class="number">85</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;doctest是一个C++单元测试库,代码仓库地址: &lt;a href=&quot;https://github.com/onqtam/doctest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/onqtam/doctest&lt;/
      
    
    </summary>
    
    
    
      <category term="unittext cpp" scheme="http://yoursite.com/tags/unittext-cpp/"/>
    
  </entry>
  
  <entry>
    <title>常用git操作</title>
    <link href="http://yoursite.com/2021/07/09/git/"/>
    <id>http://yoursite.com/2021/07/09/git/</id>
    <published>2021-07-09T15:23:31.000Z</published>
    <updated>2021-07-09T15:36:32.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="新建tag"><a href="#新建tag" class="headerlink" title="新建tag"></a>新建tag</h3><p>git tag -a v1.0 -m “new tag”</p><h3 id="tag重命名"><a href="#tag重命名" class="headerlink" title="tag重命名"></a>tag重命名</h3><ol><li>git tag new old</li><li>git tag -d old</li><li>git push origin :refs/tags/old</li><li>git push –tags</li></ol><h3 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h3><ol><li>删除本地 git tag -d v1.0</li><li>推送远端 git push origin :refs/tags/v1.0</li></ol><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>场景,需要回滚某分支,并且已经提交到remote</p><ol><li>git reset –hard commit_id</li><li>git push origin branch_name –force</li></ol><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="推送分支到远程"><a href="#推送分支到远程" class="headerlink" title="推送分支到远程"></a>推送分支到远程</h3><p>远程没有的分支,本地创建之后要推送到远程</p><ol><li>git checkout -b dev</li><li>git push origin dev:dev</li></ol><h3 id="拉取远程分支"><a href="#拉取远程分支" class="headerlink" title="拉取远程分支"></a>拉取远程分支</h3><p>拉取远程分支到本地</p><ol><li>git fetch origin branch</li><li>git checkout -b branch origin/branch</li></ol><h2 id="覆盖分支"><a href="#覆盖分支" class="headerlink" title="覆盖分支"></a>覆盖分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master // 切换到旧的分支</span><br><span class="line">git reset --hard develop // 将本地的旧分支 master 重置成 develop</span><br><span class="line">git push origin master --force // 再推送到远程仓库</span><br></pre></td></tr></table></figure><h2 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h2><h3 id="同步仓库"><a href="#同步仓库" class="headerlink" title="同步仓库"></a>同步仓库</h3><p>fork之后的仓库保持同步  </p><ul><li>进入fork之后的本地仓库</li><li>git remote add upstream <a href="https://xxx/yyy.git" target="_blank" rel="noopener">https://xxx/yyy.git</a></li><li>git remote -v 检查upstream设置成功</li><li>git fetch upstream</li><li>git merge upstream/master</li><li>git push</li></ul><p><a href="https://github.com/selfteaching/the-craft-of-selfteaching/issues/67" target="_blank" rel="noopener">参考</a></p><h3 id="本地仓库推到远端空仓库"><a href="#本地仓库推到远端空仓库" class="headerlink" title="本地仓库推到远端空仓库"></a>本地仓库推到远端空仓库</h3><ul><li>git remote add origin <a href="https://xxx/yyy.git" target="_blank" rel="noopener">https://xxx/yyy.git</a></li><li>git push -u origin master</li></ul><h3 id="修改仓库地址"><a href="#修改仓库地址" class="headerlink" title="修改仓库地址"></a>修改仓库地址</h3><p>修改远程仓库地址之后,本地仓库设置:</p><p>git remote set-url origin ssh://xxx/yyy.git</p><h2 id="git-push-免密码"><a href="#git-push-免密码" class="headerlink" title="git push 免密码"></a>git push 免密码</h2><ol><li>首先生成密钥,并添加到github的ssh</li><li>git remote rm origin</li><li>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:account/repository.git</li><li>git push –set-upstream origin master</li></ol><h2 id="下载仓库某分支"><a href="#下载仓库某分支" class="headerlink" title="下载仓库某分支"></a>下载仓库某分支</h2><p>requirements.txt文件将对py包的依赖整理到一个文件,方便配置依赖包</p><p>可以将某个需要指定分支或tag的代码仓库配置在依赖文件中</p><h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>正常每行格式如下</p><p><code>pep8==1.7.1</code></p><p>使用 <code>pip freeze &gt; requirements.txt</code> 将环境中所有的库都输出</p><p><code>sudo pip3 install pipreqs &amp;&amp; pipreqs .</code> 命令自动生成项目依赖</p><h3 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h3><p><code>pip3 install -r requirements.txt</code></p><p>如果要安装github上的某个分支,文件要按如下格式:</p><p><code>-e git+https://xxx/yyy.git#dev@egg=name</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tag&quot;&gt;&lt;a href=&quot;#tag&quot; class=&quot;headerlink&quot; title=&quot;tag&quot;&gt;&lt;/a&gt;tag&lt;/h2&gt;&lt;h3 id=&quot;新建tag&quot;&gt;&lt;a href=&quot;#新建tag&quot; class=&quot;headerlink&quot; title=&quot;新建tag&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>linux相关之文本处理</title>
    <link href="http://yoursite.com/2021/06/27/linux-text-process/"/>
    <id>http://yoursite.com/2021/06/27/linux-text-process/</id>
    <published>2021-06-27T09:59:01.000Z</published>
    <updated>2021-06-27T10:13:32.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>使用正则匹配多个数字跟G加tab并输出<br><code>awk &#39;/[0-9]+G\t/{print}&#39; filename</code></p><p>正则提取字符串,存储()中的内容为数组,并通过索引获取  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;match($0,/[0-9]+.[0-9]+/,a);print a[0]&#125;'</span> lines</span><br><span class="line">awk <span class="string">'&#123;match($0,/.+is([^,]+).+not(.+)/,a);print a[1],a[2]&#125;'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed 双引号支持变量引用/转义符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消除文件^M</span></span><br><span class="line">sed <span class="string">'s/\r//g'</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时替换多个</span></span><br><span class="line">sed -e <span class="string">""</span> -e <span class="string">""</span> filename </span><br><span class="line"></span><br><span class="line"><span class="comment"># 原地替换 </span></span><br><span class="line">sed -i <span class="string">'s/ /\n/g'</span> filename</span><br></pre></td></tr></table></figure><h2 id="paste-split"><a href="#paste-split" class="headerlink" title="paste/split"></a>paste/split</h2><p>将多个文件作为多列来拼接<br><code>paste file1 file2 -d &#39;,&#39;</code></p><p>split分割文件</p><ul><li><p>按行数分割 <code>split -l 1000 file -d -a 4 prefix</code> 分割后文件前缀为prefix,文件名后缀是数字而非默认的字母,后缀系数为4位</p></li><li><p>按大小分割 <code>split -b 10m file</code></p></li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>查找多个条件<br>统计c++项目源代码行数<br><code>find . -regex &quot;.*\(\.cpp\|\.h\|\.hpp\|\.c\)$&quot; -exec wc -l {} \; | awk &#39;{s+=$1}END{print s}&#39;</code></p><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>比较文件异同</p><p>diff 默认普通模式 -c 上下文模式 -u 合并模式</p><p>vimdiff 相当于vim -d</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep如何匹配转义字符如\t<br><code>grep &quot;prefix&quot;$&#39;\t&#39; filename</code></p><p>grep进行正则的提取<br><code>grep -P &#39;\(.*\)&#39; -o</code></p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>遇到vim写py缩进问题,一般是tab和空格混用,可以 <code>%s/\t/    /g</code> 将所有tab转成空格</p><p>报错 vim  E667: Fsync failed<br>无法编辑和保存home目录下文件,但是nano可以编辑<br>一般是磁盘空间满了,或者有空间但是系统限制了配额,如集群会限制每人home目录如100M的配额,而很多库及软件的缓存目录都默认在home目录,可以使用软连接将目录链接到其他磁盘,空出home目录的磁盘空间</p><p>反撤销 ctrl+r</p><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>xargs主要用于将标准输入转换为参数,适用于部分命令不支持标准输入的情况<br><code>cat arg.txt | xargs -I {} ./test.sh -p {} -l</code></p><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>获取上一条命令执行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [[ $? == 0 ]];</span><br><span class="line">then</span><br><span class="line">    xxx</span><br><span class="line">else</span><br><span class="line">    xxx</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>判断路径是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -e "$binPath" ];</span><br><span class="line">then</span><br><span class="line">    mkdir $binPath</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>test 命令<br><code>test -z a</code> 检查字符串a是否为null,如果为null,返回true</p><p>参数：</p><ul><li>$# 参数个数</li><li>$* 所有参数,一个单字符串显示</li><li>$$ 脚本运行的当前进程ID</li><li>$! 后台运行的最后一个进程ID</li><li>$@ 所有参数，每个参数加引号</li><li>$? 命令的推出状态，0表示无错</li><li>$1 第一个参数</li></ul><p>生成序列 for</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..2&#125;;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;awk&quot;&gt;&lt;a href=&quot;#awk&quot; class=&quot;headerlink&quot; title=&quot;awk&quot;&gt;&lt;/a&gt;awk&lt;/h2&gt;&lt;p&gt;使用正则匹配多个数字跟G加tab并输出&lt;br&gt;&lt;code&gt;awk &amp;#39;/[0-9]+G\t/{print}&amp;#39; file
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux相关之程序</title>
    <link href="http://yoursite.com/2021/06/19/linux-program/"/>
    <id>http://yoursite.com/2021/06/19/linux-program/</id>
    <published>2021-06-19T12:55:13.000Z</published>
    <updated>2021-06-19T13:13:48.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h2><p><code>$!</code> 获取上一条命令的进程ID,一般用来监控后台进程,举例:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台启动redis服务,当脚本退出时通过检测进程ID来杀掉redis进程</span></span><br><span class="line">./redis-server &amp;</span><br><span class="line">PID=$!</span><br><span class="line">...</span><br><span class="line">PID_EXIST=$(ps aux | awk <span class="string">'&#123;print $2&#125;'</span> | grep -w <span class="variable">$PID</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$PID_EXIST</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'No redis server running'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$&#123;PID&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="dev-shm-的使用"><a href="#dev-shm-的使用" class="headerlink" title="/dev/shm 的使用"></a>/dev/shm 的使用</h2><p>/dev/shm是系统中内存模拟的目录,因此读写速度很高,超过磁盘</p><p>可以用来进行大型代码仓库的编译(如将cmake的编译路径设置到/dev/shm),以及性能瓶颈测试,排除磁盘IO的影响(如本来要输出到磁盘的内容写到/dev/shm)</p><p>默认大小是ram的一半,因此要注意不要用多了(可以修改大小),会影响其他进程的可用内存;因为是内存,系统重启之后会被清空</p><h2 id="查看依赖库"><a href="#查看依赖库" class="headerlink" title="查看依赖库"></a>查看依赖库</h2><p>当程序报错找不到依赖库,或需要将程序打包移植到其他机器上时,可以使用 ldd 命令查找依赖库</p><p><code>ldd exe/xx.so</code></p><p>查看库/可执行文件的符号信息,可用于排查函数定义冲突,如某些程序对glibc版本的要求与系统安装的版本不同</p><p><code>nm *.lib</code></p><h2 id="监控程序"><a href="#监控程序" class="headerlink" title="监控程序"></a>监控程序</h2><p>查看一个进程的线程数 <code>ps hH p &lt;pid&gt; |wc -l</code></p><p>查看当前bash的所有进程 <code>ps -l</code></p><p>top命令排序</p><ul><li>P 按CPU使用率排序</li><li>M 按内存占用排序</li></ul><h2 id="生成-core文件用于debug"><a href="#生成-core文件用于debug" class="headerlink" title="生成.core文件用于debug"></a>生成.core文件用于debug</h2><ul><li><code>ulimit -c unlimited</code> 当发生段错误,设置生成dump文件</li><li><code>ulimit -c 0</code> 取消dump文件</li><li><code>ulimit -a</code> 查看当前设置</li></ul><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>cmake指定gcc的版本,在shell中设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=/usr/<span class="built_in">local</span>/bin/gcc</span><br><span class="line"><span class="built_in">export</span> CXX=/usr/<span class="built_in">local</span>/bin/g++</span><br></pre></td></tr></table></figure><p>cmake编译软件指定安装路径,多用于非管理员权限编译安装软件<br><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><p>Q: 编译安装cmake <code>./bootstrap --prefix=xx &amp;&amp; make &amp;&amp; make install</code> 报错 <code>The C++ compiler does not support C++11 (e.g.  std::unique_ptr).</code><br>A: 原因是源代码目录是挂载目录,换个地址如/dev/shm <a href="https://stackoverflow.com/questions/50764046/c11-stdunique-ptr-error-cmake-3-11-3-bootstrap" target="_blank" rel="noopener">stackoverflow</a></p><p>Q: find_package()找不到库<br>A: 可以set(name_DIR xxx) 指定包含库的cmake的路径,会去下面查找Findname.cmake文件</p><p>清除缓存<br>cmake 没有提供clean目录的指令,通常做法是创建 build 目录,直接删除build下所有文件和文件夹来清除缓存 <code>cmake .. -B build</code></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译后去可执行文件的当前目录查找动态链接库,需要增加选项 <code>-Wl,-rpath,&#39;$ORIGIN&#39;</code></p><h2 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h2><p>valgrind –tool=callgrind –separate-threads=yes ./exproxy<br>为每个线程单独生成一个性能分析文件</p><p><a href="https://blog.csdn.net/sunmenggmail/article/details/10543483" target="_blank" rel="noopener">linux下利用valgrind工具进行内存泄露检测和性能分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取进程ID&quot;&gt;&lt;a href=&quot;#获取进程ID&quot; class=&quot;headerlink&quot; title=&quot;获取进程ID&quot;&gt;&lt;/a&gt;获取进程ID&lt;/h2&gt;&lt;p&gt;&lt;code&gt;$!&lt;/code&gt; 获取上一条命令的进程ID,一般用来监控后台进程,举例:&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux相关之系统</title>
    <link href="http://yoursite.com/2021/06/08/linux-system/"/>
    <id>http://yoursite.com/2021/06/08/linux-system/</id>
    <published>2021-06-08T12:36:35.000Z</published>
    <updated>2021-06-08T14:27:37.627Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要是关于 centos7 的总结</p><h2 id="系统版本信息"><a href="#系统版本信息" class="headerlink" title="系统版本信息"></a>系统版本信息</h2><p>查看系统内核版本信息<br><code>cat /proc/version</code><br><code>uname -a</code></p><p>查看centos版本,如centos 7.9<br><code>cat /etc/redhat-release</code></p><p>查看CPU型号及支持的指令集  </p><ul><li><code>gcc -march=native -Q --help=target|grep march</code> </li><li><code>cat /proc/cpuinfo</code>  </li><li><code>cpuid</code> (需安装此命令)</li></ul><h2 id="centos增删用户"><a href="#centos增删用户" class="headerlink" title="centos增删用户"></a>centos增删用户</h2><p>增加用户  </p><ol><li><code>adduser xx</code> 创建用户</li><li><code>passwd xx</code> 按提示设置密码</li><li>修改 /etc/sudoers 文件为可写权限, 添加一行 <code>xx  ALL=(ALL)       ALL</code> ,再改为只读权限</li></ol><p>删除用户<br><code>userdel xx</code> </p><h2 id="交换内存"><a href="#交换内存" class="headerlink" title="交换内存"></a>交换内存</h2><p><code>free -m</code> 查看交换内存情况</p><p>通过swap分区文件增加swap空间</p><ol><li><code>dd if=/dev/zero of=swapfile bs=1M count=1024</code> bs是每个块大小,count是块数量,这里设置共1G</li><li><code>mkswap swapfile</code> 格式化交换分区文件</li><li><code>swapon swapfile</code> 启用</li><li>设置开机自启. 修改/etc/fstab 文件添加一行 <code>swapfile swap swap defaults 0 0</code> 注意使用全路径</li></ol><p>使用文件作为交换内存的好处:</p><ol><li>如果磁盘空间不足,可以删除文件,释放部分磁盘空间,为抢救数据争取时间</li><li>在资源不足时增加虚拟内存</li></ol><h2 id="磁盘性能"><a href="#磁盘性能" class="headerlink" title="磁盘性能"></a>磁盘性能</h2><p>查看磁盘存储空间<br><code>df -h</code></p><p>查看某进程的磁盘读写速度(需执行命令 <code>yum install -y pidstat</code>)<br><code>pidstat -p ${pid} -d 1</code>  </p><p>检测磁盘读写速度,一种不太准确的方式<br>写 <code>dd if=/dev/zero of=test.file bs=1G count=2 oflag=direct</code><br>读 <code>dd if=test.file of=/dev/null  iflag=direct</code></p><h2 id="查询端口"><a href="#查询端口" class="headerlink" title="查询端口"></a>查询端口</h2><p>在win下查看linux的端口是否打开(需开启telnet服务)<br><code>telnet 172.17.15.12 8000</code></p><p><code>netstat -nlp | grep 8080</code> 查看本机端口  </p><p><code>systemctl start firewalld</code> 开启防火墙<br><code>firewall-cmd --query-port=666/tcp</code> 查看想开的端口是否已开<br><code>firewall-cmd --add-port=666/tcp</code> 开端口号<br><code>firewall-cmd --remove-port=666/tcp</code> 移除端口  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里主要是关于 centos7 的总结&lt;/p&gt;
&lt;h2 id=&quot;系统版本信息&quot;&gt;&lt;a href=&quot;#系统版本信息&quot; class=&quot;headerlink&quot; title=&quot;系统版本信息&quot;&gt;&lt;/a&gt;系统版本信息&lt;/h2&gt;&lt;p&gt;查看系统内核版本信息&lt;br&gt;&lt;code&gt;cat /pr
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>singularity容器使用心得</title>
    <link href="http://yoursite.com/2021/05/30/singularity-container/"/>
    <id>http://yoursite.com/2021/05/30/singularity-container/</id>
    <published>2021-05-30T10:03:10.000Z</published>
    <updated>2021-05-30T10:07:06.230Z</updated>
    
    <content type="html"><![CDATA[<p>将软件或流程打包进容器,可以方便地在云上进行大规模部署,这里记录下自己使用singularity工具的过程</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>centos 系统推荐安装方式 <code>yum install -y singularity</code></p><p><a href="https://sylabs.io/guides/3.7/admin-guide/installation.html#install-nonsetuid" target="_blank" rel="noopener">官网安装链接</a><br><a href="https://github.com/hpcng/singularity/blob/master/INSTALL.md" target="_blank" rel="noopener">Installing Singularity</a></p><p>手动安装,需要把singularity安装包放到go安装包里面</p><p>设置go代理 <code>go env -w GOPROXY=https://goproxy.cn,direct</code><br>如果不生效,直接修改Makefile中的配置</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>沙盒模式方便交互式修改配置,直到满意为止;定义文件模式更加规范,使安装更新软件变得简单</p><h3 id="沙盒模式"><a href="#沙盒模式" class="headerlink" title="沙盒模式"></a>沙盒模式</h3><p>build 命令会创建一个ubuntu/centos7目录,里面有整个对应的操作系统,在你当前工作目录中会有一个Singularity元数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo singularity build --sandbox ubuntu library://ubuntu</span><br><span class="line"></span><br><span class="line">$ sudo singularity build --sandbox centos7 docker://centos:7</span><br></pre></td></tr></table></figure><p>你可以在这个目录中使用shell,exec和run等命令就像你在一个Singularity镜像中.如果当你使用容器的时候传递了–writable 选项,你也可以在沙盒目录中对文件进行读写（当你有对应的权限时）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo singularity <span class="built_in">exec</span> --writable centos7 touch /foo</span><br><span class="line"></span><br><span class="line">$ sudo singularity <span class="built_in">exec</span> centos7 ls /foo</span><br><span class="line">/foo</span><br><span class="line"></span><br><span class="line">$ sudo singularity shell --writable centos7</span><br><span class="line">Singularity&gt; rm -rf /foo</span><br><span class="line">Singularity&gt; ls /foo</span><br><span class="line">ls: cannot access /foo: No such file or directory</span><br><span class="line">Singularity&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h3 id="定义文件模式"><a href="#定义文件模式" class="headerlink" title="定义文件模式"></a>定义文件模式</h3><p>定义文件是后缀为.def的纯文本文件,格式分为文件头和文件主体</p><p>文件头指定基础容器来源</p><p>文件主体是一系列sections:</p><ul><li>setup. 首先执行于host环境,可以访问 $SINGULARITY_ROOTFS 容器的根目录,是在宿主目录的/tmp目录下临时建的;推荐使用 %files 来拷贝文件</li><li>files. 拷贝文件,可以从host拷贝到容器,或者从容器的某个步骤拷贝,格式是两列,source dest</li><li>post. 网络下载,安装库,写配置文件,创建目录; $SINGULARITY_ENVIRONMENT = /.singularity.d/env/91-environment.sh 可以写入这个配置文件,build time使用</li><li>test. 做检查验证</li><li>environment. export环境变量,用于run time,如果build time需要用到,去post中设置</li><li>runscript. 运行镜像,exec prog “$@” 来调用可执行</li><li>labels. 加作者,版本信息</li></ul><p><a href="https://sylabs.io/guides/3.5/user-guide/definition_files.html" target="_blank" rel="noopener">官方文档-定义文件</a></p><p>一个简单的示例,演示了以centos 7为基础镜像,拷贝文件,安装java和python等</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filename: simple.def</span></span><br><span class="line">Bootstrap: docker</span><br><span class="line">From:centos:7.6.1810</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">    <span class="comment"># 拷贝当前目录下的某文件到镜像的/opt目录</span></span><br><span class="line">    <span class="variable">$PWD</span>/simple.def /opt</span><br><span class="line"></span><br><span class="line">%post</span><br><span class="line">    yum install -y -q wget</span><br><span class="line"></span><br><span class="line">    <span class="comment"># install java</span></span><br><span class="line">    <span class="built_in">cd</span> /opt &amp;&amp; wget -q https://repo.huaweicloud.com/java/jdk/8u171-b11/jdk-8u171-linux-x64.tar.gz &amp;&amp; \</span><br><span class="line">        tar zxf jdk-8u171-linux-x64.tar.gz &amp;&amp; mv jdk1.8.0_171 java</span><br><span class="line">    rm jdk-8u171-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">    <span class="comment"># install python</span></span><br><span class="line">    yum install python3 -y -q</span><br><span class="line">    pip3 install -q opencv-python -i https://pypi.douban.com/simple</span><br><span class="line"></span><br><span class="line">%environment</span><br><span class="line">    <span class="comment"># set java path</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/java/bin</span><br><span class="line">    <span class="built_in">export</span> LC_ALL=C</span><br><span class="line"></span><br><span class="line">%runscript</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Arguments received: $*"</span></span><br><span class="line">    python3</span><br><span class="line"></span><br><span class="line">%labels</span><br><span class="line">    Author tigeroses</span><br><span class="line">    Version v1.0</span><br></pre></td></tr></table></figure><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>不管是沙盒模式的一个目录还是定义文件模式的一个文件,最终要给用户使用都需要打包成后缀为.sif的镜像文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沙盒模式</span></span><br><span class="line"><span class="comment"># -F 表示覆盖已存在的sif文件,用于需要反复测试打包的情况</span></span><br><span class="line">sudo singularity build -F my_container.sif centos7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件模式</span></span><br><span class="line">sudo singularity build -F my_container.sif simple.def</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>拿到sif文件之后,就可以测试运行了</p><p>可以直接运行,等价于使用run命令,如果定义文件中存在 %runscript section,则会执行其中的shell 命令,适用于功能单一的软件,可以方便的使用;如果没有%runscript, 则会进入容器的交互模式</p><p>exec命令可以更灵活的执行镜像中安装的软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接运行,由于设置了python命令,则会进入python的交互界面</span></span><br><span class="line">$ ./my_container.sif</span><br><span class="line">Arguments received:</span><br><span class="line">Python 3.6.8 (default, Nov 16 2020, 16:55:22)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 run 命令</span></span><br><span class="line">$ singularity run my_container.sif</span><br><span class="line">Arguments received:</span><br><span class="line">Python 3.6.8 (default, Nov 16 2020, 16:55:22)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 exec 命令</span></span><br><span class="line">$ singularity <span class="built_in">exec</span> my_container.sif java -version</span><br><span class="line">java version <span class="string">"1.8.0_171"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>其他:</p><ul><li>如果有需要临时修改镜像内部数据,exec命令增加 <code>--writable-tmpfs</code></li><li>默认镜像只能访问$HOME目录,因此需要绑定目录,如将外部的/opt目录绑定为/mnt目录, 增加命令 <code>--bind /opt:/mnt</code> 容器使用 /mnt 来访问宿主机 /opt 中的文件; 可以绑定多个目录</li><li>如果使用了mysql,由于每次使用容器数据库会被刷新,为防止丢失数据,需要将mysql的数据目录放到本地磁盘上,绑定目录如 <code>--bind /opt/mysql/var/lib/mysql/:/var/lib/mysql --bind /opt/mysql/run/mysqld:/run/mysqld</code></li></ul><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="定制基础镜像"><a href="#定制基础镜像" class="headerlink" title="定制基础镜像"></a>定制基础镜像</h3><p>对于较大的项目,安装库和环境较复杂可能会导致打包容器镜像耗时较久,影响开发效率,而一些库和软件如python java等会比较稳定,因此可以把比较稳定的软件与经常更新的软件隔离开,分层次先打包基础镜像,然后每次发布新版本可以在基础镜像之上打包发布</p><p>示例:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filename: base.def</span></span><br><span class="line">Bootstrap: docker</span><br><span class="line">From:centos:7.6.1810</span><br><span class="line"></span><br><span class="line">%post</span><br><span class="line">    yum install -y -q wget</span><br><span class="line"></span><br><span class="line">    <span class="comment"># install java</span></span><br><span class="line">    <span class="built_in">cd</span> /opt &amp;&amp; wget -q https://repo.huaweicloud.com/java/jdk/8u171-b11/jdk-8u171-linux-x64.tar.gz &amp;&amp; \</span><br><span class="line">        tar zxf jdk-8u171-linux-x64.tar.gz &amp;&amp; mv jdk1.8.0_171 java</span><br><span class="line">    rm jdk-8u171-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">%environment</span><br><span class="line">    <span class="comment"># set java path</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/java/bin</span><br><span class="line">    <span class="built_in">export</span> LC_ALL=C</span><br></pre></td></tr></table></figure><p>打包base.sif <code>sudo singularity build -F base.sif base.def</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filename: simple.def</span></span><br><span class="line"><span class="comment"># 注意基础镜像的来源要修改</span></span><br><span class="line">Bootstrap: localimage</span><br><span class="line">From:base.sif</span><br><span class="line"></span><br><span class="line">%post</span><br><span class="line">    <span class="comment"># install python</span></span><br><span class="line">    yum install python3 -y -q</span><br></pre></td></tr></table></figure><p>打包simple.sif <code>sudo singularity build -F simple.sif simple.def</code></p><p>测试执行,可以看到java和python都可以使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ singularity <span class="built_in">exec</span> simple.sif java -version</span><br><span class="line">java version <span class="string">"1.8.0_171"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br><span class="line"></span><br><span class="line">$ singularity <span class="built_in">exec</span> simple.sif python3 -c <span class="string">"print('hello world')"</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="在容器中运行服务"><a href="#在容器中运行服务" class="headerlink" title="在容器中运行服务"></a>在容器中运行服务</h3><p>这里模拟下如何使用supervisor软件在容器中运行redis服务</p><p>准备supervisor需要的两个配置文件</p><p>redis.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:redis]</span></span><br><span class="line"><span class="attr">command</span>=redis-server</span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">priority</span>=<span class="number">20</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/mnt/logs/redis/redis.out.log</span><br><span class="line"><span class="attr">stderr_logfile</span>=/mnt/logs/redis/redis.err.log</span><br></pre></td></tr></table></figure><p>默认的supervisord.conf,修改下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/mnt/supervisor/supervisor.sock</span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/mnt/supervisor/supervisord.log</span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///mnt/supervisor/supervisor.sock</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /opt/redis.ini</span><br></pre></td></tr></table></figure><p>定义文件如下,安装redis/supervisor</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filename: server.def</span></span><br><span class="line">Bootstrap: docker</span><br><span class="line">From:centos:7.6.1810</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">    <span class="variable">$PWD</span>/supervisord.conf /opt</span><br><span class="line">    <span class="variable">$PWD</span>/redis.ini /opt</span><br><span class="line"></span><br><span class="line">%post</span><br><span class="line">    <span class="comment"># install redis</span></span><br><span class="line">    yum install -y -q gcc*</span><br><span class="line">    yum install -y -q wget make</span><br><span class="line">    <span class="built_in">cd</span> /opt  &amp;&amp; wget -q http://download.redis.io/releases/redis-4.0.6.tar.gz &amp;&amp; \</span><br><span class="line">        tar xzf redis-4.0.6.tar.gz &amp;&amp; <span class="built_in">cd</span> redis-4.0.6 &amp;&amp; make -s &amp;&amp; make install -s</span><br><span class="line">    rm /opt/redis-4.0.6.tar.gz</span><br><span class="line"></span><br><span class="line">    yum install python3 -y -q</span><br><span class="line">    pip3 install supervisor -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><p>测试:</p><ul><li>打包. <code>singularity build -F server.sif server.def</code></li><li>创建目录. <code>mkdir -p $PWD/supervisor $PWD/logs/redis</code></li><li>运行.<ul><li>开启supervisord服务. <code>singularity exec --bind $PWD:/mnt server.sif supervisord</code></li><li>查看服务状态. <code>singularity exec --bind $PWD:/mnt server.sif supervisorctl status</code></li><li>关闭服务. <code>singularity exec --bind $PWD:/mnt server.sif supervisorctl stop all</code></li><li>开启服务. <code>singularity exec --bind $PWD:/mnt server.sif supervisorctl start all</code></li><li>杀掉supervisord服务. <code>ps -ef | grep supervisord</code> 找到进程ID,再使用 <code>kill -9 ID</code> 杀掉进程</li></ul></li></ul><p>实际使用过程可以把命令封装成脚本调用,使用户使用起来更加简洁</p><h3 id="容器加密"><a href="#容器加密" class="headerlink" title="容器加密"></a>容器加密</h3><p>正常情况下打包的容器镜像,用户可以通过shell命令进入容器内部,如果想限制别人的使用,就涉及到容器的加密</p><p>密钥方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate a keypair</span></span><br><span class="line">$ ssh-keygen -t rsa -b 2048</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa): rsa</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">[snip...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the public key to PEM PKCS1 format</span></span><br><span class="line">$ ssh-keygen -f rsa.pub -e -m pem &gt; rsa_pub.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rename the private key (already PEM PKCS1) to a nice name</span></span><br><span class="line">$ mv rsa rsa_pri.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">$ sudo singularity build -F --pem-path=rsa_pub.pem base.sif base.def</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无密钥情况会报错无法访问</span></span><br><span class="line">$ ./base.sif</span><br><span class="line">FATAL:   Unable to use container encryption. Must supply encryption material through environment variables or flags.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">$ singularity shell --pem-path=rsa_pri.pem base.sif</span><br><span class="line">Singularity&gt;</span><br></pre></td></tr></table></figure><p>密码方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互方式输入密码,也可以选择</span></span><br><span class="line"><span class="comment"># export SINGULARITY_ENCRYPTION_PASSPHRASE=$(cat secret.txt)导入环境变量来设置密码</span></span><br><span class="line">$ sudo singularity build -F --passphrase base.sif base.def</span><br><span class="line">Enter encryption passphrase:</span><br><span class="line">INFO:    Starting build...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互方式验证密码</span></span><br><span class="line">$ singularity shell --passphrase base.sif</span><br><span class="line">Enter encryption passphrase:</span><br><span class="line">Singularity&gt;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://sylabs.io/guides/3.6/user-guide/encryption.html" target="_blank" rel="noopener">Encrypted Containers</a></li><li><a href="https://sylabs.io/guides/3.6/user-guide/running_services.html" target="_blank" rel="noopener">Running Services</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将软件或流程打包进容器,可以方便地在云上进行大规模部署,这里记录下自己使用singularity工具的过程&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;centos 系统
      
    
    </summary>
    
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>监控进程内存</title>
    <link href="http://yoursite.com/2020/09/21/moniter-process-memory/"/>
    <id>http://yoursite.com/2020/09/21/moniter-process-memory/</id>
    <published>2020-09-21T13:47:53.000Z</published>
    <updated>2020-09-21T14:00:20.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>需要获取某程序运行过程中的内存消耗,一般情况可以使用 <code>top</code> 命令来人工分析,不过我遇到一个程序其内部调用包括 python, R, 以及一系列 linux 命令,这就导致人工统计不太现实</p><p>问题变成统计进程及其子进程的内存使用,可以通过 <code>pstree</code> 命令查看进程与子进程的关系,但是其输出图形,不太方便获取所有子进程ID,因此打算自己编写 C++ 代码来实现</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用伪码表示:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当待查询进程存在:</span><br><span class="line">    遍历用户所有进程,获取每个进程的ID和父进程ID及内存</span><br><span class="line">    维护一个表,记录与待查询进程相关的子进程及其内存,初始化只有待查询进程</span><br><span class="line">    遍历所有进程:</span><br><span class="line">        如果当前进程的父进程在表中:</span><br><span class="line">            将此进程及对应内存加入表</span><br><span class="line">    汇总表,得出总内存,并打印</span><br></pre></td></tr></table></figure><p>这里细节是如何高效的更新表,可以将问题抽象为由一组边来构建树的过程,每个进程都有唯一的进程id(pid)和父进程id(ppid),正常来说一个系统所有的进程可以构建成一棵树(linux系统上所有进程都是由其他进程fork来的),不过我们只想查询某个用户下的进程,因此结果会构建成多棵树,只要遍历找到某个树的某个节点为感兴趣的进程id,以此节点作为根节点,遍历整棵树汇总内存即为结果</p><p>不过为了实现简单,我这里没有采用构建树的方式,而是直接遍历,遇到相关的进程就更新进表中,同时删除掉此进程;当某次遍历后维护进程的链表长度没有发生改变,说明所有子进程已查找完毕;这种计算方式对少量数据情况还是挺快的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>查询某个进程的信息比如内存占用,父进程ID等,linux 系统可以通过解析 <code>/proc/pid/status</code> 文件来获取</p><p>查找某用户所有进程,可使用命令 <code>ps -U username</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// monitor_process.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exec_shell</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd, <span class="built_in">std</span>::<span class="built_in">string</span> &amp; res)</span></span>;</span><br><span class="line">pair&lt;int, size_t&gt; physical_memory_used_by_process(int pid);</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; <span class="title">split_str</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim=<span class="string">' '</span>, <span class="keyword">bool</span> skip_empty=<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collect_memory</span><span class="params">(<span class="keyword">int</span> root_pid, <span class="keyword">size_t</span>&amp; total_memory)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> username = <span class="string">"zhangsan"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProcessInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> ppid;</span><br><span class="line">    <span class="keyword">size_t</span> memory;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Enter &lt;pid&gt; &lt;interval&gt;\n"</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root_pid = stoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> interval = stoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> memory = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!collect_memory(root_pid, memory))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">std</span>::chrono::system_clock::time_point now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">time_t</span> now_c = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="built_in">std</span>::put_time(<span class="built_in">std</span>::localtime(&amp;now_c), <span class="string">"%F %T"</span>)&lt;&lt;<span class="string">" "</span>&lt;&lt;memory&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        sleep(interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collect_memory</span><span class="params">(<span class="keyword">int</span> root_pid, <span class="keyword">size_t</span>&amp; total_memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> get_all_process = <span class="string">"ps -U "</span> + username + <span class="string">" | awk '&#123;if (NR&gt;1) printf $1\" \"&#125;'"</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    exec_shell(get_all_process.c_str(), res);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pids = split_str(res);</span><br><span class="line">    <span class="built_in">list</span>&lt;ProcessInfo&gt; process_infos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pid : pids)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [ppid, memory] = physical_memory_used_by_process(stoi(pid));</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"pid: "&lt;&lt;pid &lt;&lt;" ppid: "&lt;&lt;ppid&lt;&lt;" "&lt;&lt;memory&lt;&lt;endl;</span></span><br><span class="line">        ProcessInfo pi;</span><br><span class="line">        pi.pid = stoi(pid);</span><br><span class="line">        pi.ppid = ppid;</span><br><span class="line">        pi.memory = memory;</span><br><span class="line">        process_infos.push_back(pi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; determined;</span><br><span class="line">    <span class="comment">// Init using the root process</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pi : process_infos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pi.pid == root_pid)</span><br><span class="line">        &#123;</span><br><span class="line">            determined.insert(&#123;root_pid, pi.memory&#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (determined.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect all childs process</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = process_infos.begin();</span><br><span class="line">        <span class="keyword">int</span> old_size = process_infos.size();</span><br><span class="line">        <span class="keyword">while</span> (iter != process_infos.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"skip pid: "&lt;&lt;iter-&gt;pid&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"determined size: "&lt;&lt;determined.size()&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (determined.count(iter-&gt;ppid) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                determined[iter-&gt;pid] = iter-&gt;memory;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;"add pid: "&lt;&lt;iter-&gt;pid&lt;&lt;" memory: "&lt;&lt;iter-&gt;memory&lt;&lt;endl;</span></span><br><span class="line">                process_infos.erase(iter);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> new_size = process_infos.size();</span><br><span class="line">        <span class="keyword">if</span> (old_size == new_size)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, m] : determined)</span><br><span class="line">        total_memory += m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exec_shell</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd, <span class="built_in">std</span>::<span class="built_in">string</span> &amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* pp = popen(cmd, <span class="string">"r"</span>);  <span class="comment">// make pipe</span></span><br><span class="line">    <span class="keyword">if</span> (!pp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">1024</span>];  <span class="comment">// store the stdout per line</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(tmp, <span class="keyword">sizeof</span>(tmp), pp) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp[<span class="built_in">strlen</span>(tmp) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[<span class="built_in">strlen</span>(tmp) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close pipe, the return code is cmd's status</span></span><br><span class="line">    <span class="comment">// returns the exit status of the terminating command processor</span></span><br><span class="line">    <span class="comment">// -1 if an error occurs</span></span><br><span class="line">    <span class="keyword">int</span> rtn = pclose(pp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">    rtn = WEXITSTATUS(rtn);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;int, size_t&gt; physical_memory_used_by_process(int pid)</span><br><span class="line">&#123;</span><br><span class="line">    pair&lt;int, size_t&gt; result(-1, 0);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">string</span> file_name = <span class="string">"/proc/"</span>+to_string(pid)+<span class="string">"/status"</span>;</span><br><span class="line">    FILE* file = fopen(file_name.c_str(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">char</span>  line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="number">128</span>, file) != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line, <span class="string">"VmRSS:"</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(line);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* p = line;</span><br><span class="line">            <span class="keyword">for</span> (; <span class="built_in">std</span>::<span class="built_in">isdigit</span>(*p) == <span class="literal">false</span>; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            line[len - <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            result.second        = atoi(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line, <span class="string">"PPid:"</span>, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(line);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* p = line;</span><br><span class="line">            <span class="keyword">for</span> (; <span class="built_in">std</span>::<span class="built_in">isdigit</span>(*p) == <span class="literal">false</span>; ++p)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.first        = atoi(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; <span class="title">split_str</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim, <span class="keyword">bool</span> skip_empty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;   res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span> item; getline(iss, item, delim);)</span><br><span class="line">        <span class="keyword">if</span> (skip_empty &amp;&amp; item.empty())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.push_back(item);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>使用 gcc9.1 编译代码 <code>g++ -std=c++17 monitor_process.cpp -o pm</code></p><p>首先运行待检测的程序,然后通过命令如 <code>top</code> 确定对应进程ID, 运行命令如 <code>./pm 25201 2</code> 监控 id 为25201的进程,刷新间隔为2秒</p><p>结果输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-09-18 17:37:05 1932</span><br><span class="line">2020-09-18 17:37:07 1932</span><br><span class="line">2020-09-18 17:37:09 1932</span><br></pre></td></tr></table></figure><p>这里输出的内存单位是 KB</p><p>注意:由于需要进程启动之后才能开启监控,导致进程内存无法从0开始;当进程结束,则监控程序也会退出</p><p>关于结果展示,直接将输出结果的第二列和第三列拷贝到 Excel 中,插入折线图即可看到内存随时间变化情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h2&gt;&lt;p&gt;需要获取某程序运行过程中的内存消耗,一般情况可以使用 &lt;code&gt;top&lt;/code&gt; 命令来人工分析,不过我遇到一个程序其内部调用包括 p
      
    
    </summary>
    
    
    
      <category term="linux cpp" scheme="http://yoursite.com/tags/linux-cpp/"/>
    
  </entry>
  
  <entry>
    <title>c++编译错误汇总</title>
    <link href="http://yoursite.com/2020/09/05/cpp-compile-error/"/>
    <id>http://yoursite.com/2020/09/05/cpp-compile-error/</id>
    <published>2020-09-05T08:52:51.000Z</published>
    <updated>2020-09-05T11:17:01.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译错误处理"><a href="#编译错误处理" class="headerlink" title="编译错误处理"></a>编译错误处理</h2><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>Q:error C2059: 语法错误:”&lt;class-head&gt;“<br>A:全局变量没有加分号,可能是复制粘贴导致的</p><p>Q:error: passing ‘const xx’ as ‘this’ argument discards qualifiers [-fpermissive]<br>A:调用const对象的非const方法报错,需要在方法声明和定义加const限定符<br>如<code>string InetAddress::ip_ntoa() const {}</code> 好的编程习惯,get类方法返回都加双重const</p><p>Q:Error: no such instruction: `shlx %rdx,(%r12),%rax’<br>A:shlx是新的intel指令,需要能支持这类新指令的汇编器,即binutils,centos6.x不行,而7.x版本可以支持<br>参考链接<br><a href="https://blog.csdn.net/superbfly/article/details/59514207" target="_blank" rel="noopener">https://blog.csdn.net/superbfly/article/details/59514207</a><br><a href="https://blog.csdn.net/wang_xijue/article/details/47128649" target="_blank" rel="noopener">https://blog.csdn.net/wang_xijue/article/details/47128649</a></p><p>Q:switch语句 jump to case label<br>A:作用域问题,不要在case下定义语句或者将每个case语句块用{} 包起来</p><p>Q:编译gcc9报错config.log “unrecognized command line option ‘-V’”<br>A:原因是较高版本的gcc不支持-V参数,修改环境变量,设置默认gcc为系统版本4.x,重新编译</p><p>Q:g++: unrecognized option ‘-static-libstdc++’<br>A:gcc4.5才引入此选项,所以必须得gcc 4.8了;而centos 6.9默认的是4.4,所以只好换centos7.x来搞,默认4.8.5;最终使用的有效指令 <code>../configure --disable-checking --enable-languages=c,c++ --disable-multilib --prefix=/path/to/software/gcc9 --enable-threads=posix</code></p><p>Q:gcc9.1编译测试报错 /usr/bin/ld: unrecognized option ‘-plugin’<br>A:原因是binutils库太旧了(负责ld链接),升级binutils</p><p>Q:gcc9编译cpp报错 test.cpp:(.text+0xa): undefined reference to `std::cout’<br>A:换成g++ 或者gcc -lstdc++</p><p>Q:list-initializer for non-class type must not be parenthesized<br>A:发生在结构体构造函数对成员变量数组进行 ({0}) 初始化,改成 {} 会按照0来初始化</p><p>Q:Error: invalid operands of types ‘const char [35]’ and ‘const char [2]’ to binary ‘operator+’<br>A:不能直接对 const char* 相加,使用string将最左侧的 char* 转换为string即可</p><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><p>Q:Clock skew detected.  Your build may be incomplete<br>A:make报错,make clean &amp; make</p><h2 id="编译警告处理"><a href="#编译警告处理" class="headerlink" title="编译警告处理"></a>编译警告处理</h2><h3 id="Wreorder"><a href="#Wreorder" class="headerlink" title="[-Wreorder]"></a>[-Wreorder]</h3><p>规则:构造函数时,初始化成员变量顺序要与类声明中顺序对应</p><h3 id="warning-backslash-and-newline-separated-by-space"><a href="#warning-backslash-and-newline-separated-by-space" class="headerlink" title="warning: backslash and newline separated by space"></a>warning: backslash and newline separated by space</h3><p>\ 连接字符串,\后面多了空格</p><h3 id="Wunused-parameter"><a href="#Wunused-parameter" class="headerlink" title="[-Wunused-parameter]"></a>[-Wunused-parameter]</h3><p>有些变量声明了但暂时未使用</p><p>可以注释掉;如果要保留,使用C++17语法 <code>[[maybe_unused]] int a;</code></p><p>部分情况遇到  ‘mayebe_unused’ attribute directive ignored [-Wattributes]</p><h3 id="Wsign-compare"><a href="#Wsign-compare" class="headerlink" title="[-Wsign-compare]"></a>[-Wsign-compare]</h3><p>两种不同类型比较,主要是有符号无符号</p><p>解决方法比较多:</p><ul><li>手动修改某一个类型</li><li>decltype. 如 <code>decltype(s.size()) len;</code></li></ul><h3 id="Wnarrowing"><a href="#Wnarrowing" class="headerlink" title="[-Wnarrowing]"></a>[-Wnarrowing]</h3><p>类型转换,降级,如从int到short</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编译错误处理&quot;&gt;&lt;a href=&quot;#编译错误处理&quot; class=&quot;headerlink&quot; title=&quot;编译错误处理&quot;&gt;&lt;/a&gt;编译错误处理&lt;/h2&gt;&lt;h3 id=&quot;gcc&quot;&gt;&lt;a href=&quot;#gcc&quot; class=&quot;headerlink&quot; title=&quot;gcc
      
    
    </summary>
    
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>程序优化总结分享</title>
    <link href="http://yoursite.com/2020/09/05/cpp-optimization/"/>
    <id>http://yoursite.com/2020/09/05/cpp-optimization/</id>
    <published>2020-09-05T08:51:44.000Z</published>
    <updated>2020-09-05T12:37:06.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h2><p>目前主要的工作任务就是对软件进行加速,即在不影响(少影响)精度的前提下,提高程序的执行速度,降低资源的消耗</p><p>对近期工作进行总结,并编写ppt在组内分享,这里再记录一下</p><h2 id="优化理论"><a href="#优化理论" class="headerlink" title="优化理论"></a>优化理论</h2><ul><li><strong>不要优化</strong>. 不成熟的优化是万恶之源,提高代码效率的同时一般会降低其可读性,可维护及可扩展性,需要仔细权衡,在无法确定真的需要的情况下不要进行盲目的优化</li><li><strong>先实现,再优化</strong>. 其一是就算计算再快,结果不正确也没有任何意义;其二是提前优化缺乏前瞻性,即你无法知道其全局的瓶颈在哪里,此时进行优化最好的情况也只能获得局部最优解</li><li><strong>20/80定律</strong>. 在这里就是少部分代码占据大部分的时间和资源消耗</li><li><strong>找到热点,迭代实验</strong>. 通过增加时间打印或者利用性能剖析工具,找到最耗时的模块,针对性进行优化,完成之后则另一个模块成为新的瓶颈,如此迭代测试,方能见成效</li><li><strong>实践是检验真理的唯一标准</strong>. 很多时候理论是可行,但实际往往是另一回事,在程序优化方面,只有亲自实践才能确定你的思路是否有效</li></ul><h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2><p>主要从六个方面来进行优化</p><h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><p>设计框架时优先考虑整体性能,然后再为单个的子系统和类设置要达到的资源占用目标<br>如考虑并行设计,每一个线程处理的数据量是否平均,其耗时与资源占用如何,需要在编码前有一定的了解</p><h3 id="类和子程序设计"><a href="#类和子程序设计" class="headerlink" title="类和子程序设计"></a>类和子程序设计</h3><blockquote><p>针对问题选择合适的数据结构和算法</p></blockquote><p>数据类型决定了程序内存消耗,算法决定了程序的执行速度</p><ul><li>示例1: 基因注释功能中查找overlap,即对bam文件中每条reads,在基因注释文件gtf中查找与之相交的基因,再进行其他处理;一般对gtf文件构建线段树,线段树的具体实现 二叉搜索树 VS 红黑树,由于二叉搜索树是非平衡的,极端情况下甚至会退化成链表,查找最坏需要O(N)的时间复杂度,而红黑树是自平衡的,平均时间复杂度为O(log(N)),因此数据结构选择红黑树能达到更好的效率</li><li>示例2: barcode序列编码成整型,如长度为10的ACGT序列可以编码成int32,只要4个字节,而使用string来存储至少需要32字节</li><li>示例3: 计算一组数的中值,即50分位点的数值,可采用以下三种方式<ol><li><em>vector + sort()</em> 使用数组存储数据,排序之后取中间的数值,由于排序需要O(NlogN),这也是整个算法的时间复杂度</li><li><em>vector + nth_element()</em> 使用标准库中的 nth_element 方法,可以降低时间复杂度到O(N)</li><li><em>map + for</em> 假如数据有不少重复,可采用条形图的方式,使用 map(有序) 来统计个数,一次for循环遍历个数即可,空间复杂度比存储全部数据要低不少,时间复杂度虽为O(N),但此处的N为 map 的key的个数,比前面的总数N要小很多</li></ol></li></ul><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>包括磁盘IO,网络IO,动态库,外部设备等</p><p>主要考虑磁盘IO问题</p><ul><li><strong>尽量使用内存</strong>. 能不读写磁盘就不读写,数据量不大的情况全部放入内存,毕竟读内存比读磁盘要快1000倍</li><li><strong>纯文本转二进制,减小写盘数据量</strong>. 如果确实需要输出一些中间文件,可考虑将纯文本转成二进制,或采用序列化/反序列化方案来降低数据量</li><li><strong>考虑异步/多线程读写</strong>. 如多线程并行读写,异步主要指在数据计算的时候进行拷贝操作,典型的如GPU编程中多流的应用,在处理第二批数据时,将第一批已经处理结束的数据拷贝回CPU,同时将第三批数据拷贝至GPU,达到掩盖数据IO的目的</li><li><strong>更换硬盘</strong></li></ul><h3 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h3><ul><li>选择优秀的编译器软件</li><li>设置合适的编译优化参数. 如gcc的优化参数 O1 O2 O3的选择</li><li>编写出编译器能够有效转化以转换成高效可执行代码的源码. 需要对编译器原理有一定了解</li><li>编译器的局限性. 如C指针的内存别名问题(可使用restrict限定符来解决)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器不敢进行优化,只能次序执行两条指令,原因就是假如xp yp指向同一地址,</span></span><br><span class="line"><span class="comment">// 那么非次序执行的情况下结果会出现异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle</span><span class="params">(<span class="keyword">long</span>* xp, <span class="keyword">long</span>* yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li><strong>购买新的硬件设备</strong>. 如固态硬盘替换机械硬盘,百兆光纤升级为千兆,采购更高主频和核数的CPU等</li><li><strong>GPU/TPU/FPGA/ASIC</strong>. 假如CPU能力已经达到饱和,可以考虑使用硬件加速</li></ul><h3 id="代码调整"><a href="#代码调整" class="headerlink" title="代码调整"></a>代码调整</h3><ul><li><strong>调整判断次序</strong>. 在if-then-else/switch case 中将最可能出现的情况放到前面,减少判断次数</li><li><strong>知道答案后提前退出</strong></li><li><strong>查询表代替复杂表达式</strong>. 使用查询表而非临时计算,有时候可以作为降维打击了</li><li><strong>循环</strong><ol><li>将判断外提</li><li>合并多个循环</li><li>展开. 如 k * 1 展开, k * k 展开(引入k个临时变量)</li><li>哨兵值. 如在数组中查找某个值,则每次循环都需要检查数组是否越界,那么在数组末尾添加想要查找的值,则无需判断越界问题,因为肯定会返回,当然最后需要对结果所在的索引位置进行额外的判断</li><li>削减强度. 用多次轻量级运算代替一次代价高额的运算,如移位代替整数的 *2 /2</li></ol></li><li><strong>尽量减少数组引用,引入临时变量</strong>. 很多时候内存访问开销很大,引入临时变量,当全部计算完再写入内存</li><li><strong>删除公共子表达式</strong>. 提前计算好,直接使用</li><li><strong>减少过程调用</strong>. 这里主要指函数调用的开销,可以使用 inline</li><li><strong>使用低级语言重写代码</strong>. C++对应的低级语言就是汇编,python对应的就是C了</li><li><strong>理解现代处理器,利用指令级并行</strong>. 现在主流的CPU都是SIMD模式,即单指令多数据,每条指令可以操作多个数据,如intel的SSE指令集AVX,其向量长度为32字节,意味着一条指令同时可以操作8个int32数据,利用好可以达到很高的加速比</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>使用缓存,以空间换时间</p><ul><li>示例1: 注释模块处理 bam 文件,由于bam已序,我发现不少相邻的reads 注释的结果是一样的,通过使用缓存可以降低计算量</li><li>示例2: 可视化库plotly.js 中计算color,它将输入color计算为输出color,当需要显示的点数达到几M时,它的for 循环需要10s才能完成,通过简单的统计分析,我发现几M个点真正不重复的只有几百个,而相同的输入导致相同的输出,这里增加缓存可以将耗时降低到几百毫秒,可谓优秀;不过这是针对我们特定的数据集,它作为一个通用的库,自然要考虑更全面一些</li></ul><p>优化前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isArrayColorIn || isArrayOpacityIn) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        colori = getColor(colorIn, i);</span><br><span class="line">        opacityi = getOpacity(opacityIn, i);</span><br><span class="line">        colorOut[i] = calculateColor(colori, opacityi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> colorOut = calculateColor(rgba(colorIn), opacityIn);</span><br></pre></td></tr></table></figure><p>优化后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isArrayColorIn || isArrayOpacityIn) &#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[colorIn[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            colorOut[i] = cache[colorIn[i]];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colori = getColor(colorIn, i);</span><br><span class="line">        opacityi = getOpacity(opacityIn, i);</span><br><span class="line">        colorOut[i] = calculateColor(colori, opacityi);</span><br><span class="line">        cache[colorIn[i]] = colorOut[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> colorOut = calculateColor(rgba(colorIn), opacityIn);</span><br></pre></td></tr></table></figure><h3 id="性能剖析工具"><a href="#性能剖析工具" class="headerlink" title="性能剖析工具"></a>性能剖析工具</h3><p>win下vs的性能探查器, linux下可使用 gprof/valgrind</p><p>可以清晰的看到函数调用层次,时间占比等,帮助我们定位瓶颈所在</p><h3 id="降内存"><a href="#降内存" class="headerlink" title="降内存"></a>降内存</h3><ul><li><strong>削弱运算强度</strong>. 如double转float</li><li><strong>对数据进行编码</strong>. 如ACGT每字符可编码为2bit</li><li><strong>预留内存</strong>. 如果可以提前知道数据的长度,可使用 reserve/resize 提前预留内存</li><li><strong>传值 vs 传引用</strong>. 函数调用时,如果传值,则会发生内存拷贝</li><li><strong>警惕内存泄漏</strong></li><li><strong>内存复用</strong>. 内存的频繁申请和释放是很耗时的,因为需要操作系统去查找合适的内存空间,特别是实时计算过程,最好在程序或服务启动时分配好需要的内存</li></ul><h3 id="常见的低效之源"><a href="#常见的低效之源" class="headerlink" title="常见的低效之源"></a>常见的低效之源</h3><ul><li><strong>不必要的输入输出</strong>. 如磁盘IO,而这些设备是我们无法控制的</li><li><strong>分页</strong>. 一般页面大小是4k,考虑二维数组的访问,假如是行存储方式,且每行长度超过4k数据,如果每次按列访问元素,则每次都需要加载新的内存页,这无疑会导致低效率</li><li><strong>系统调用</strong>. 考虑一个第三方库,它虽然实现了你想要的功能,但也有可能其进行了一些对你来说不必要的操作,如对输入数据的判断,一些异常情况的处理等,假如可以保证我们的数据没有问题,那么这些操作就是可以避免的,此时可以手动实现我们想要的功能,来替换一些库的调用</li><li><strong>错误</strong>. 如数据库没有建立索引导致查询低效,编译器没有开启优化等操作</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>&lt;代码大全&gt;第25,26章</li><li>&lt;深入理解计算机系统&gt;第6章</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来由&quot;&gt;&lt;a href=&quot;#来由&quot; class=&quot;headerlink&quot; title=&quot;来由&quot;&gt;&lt;/a&gt;来由&lt;/h2&gt;&lt;p&gt;目前主要的工作任务就是对软件进行加速,即在不影响(少影响)精度的前提下,提高程序的执行速度,降低资源的消耗&lt;/p&gt;
&lt;p&gt;对近期工作进行总结
      
    
    </summary>
    
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>vscode连接远程服务器</title>
    <link href="http://yoursite.com/2020/09/05/vscode-remote-secondary-verification/"/>
    <id>http://yoursite.com/2020/09/05/vscode-remote-secondary-verification/</id>
    <published>2020-09-05T08:51:13.000Z</published>
    <updated>2020-09-05T09:29:17.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>vscode有远程开发功能,即可以在windows打开vscode,连接上linux服务器写代码<br>但由于公司集群登录节点是centos6,官方表示centos6需要升级glibc和libstdc++,没有管理员权限,只能找一台centos7的计算节点,想办法跳过登录节点</p><h2 id="使用ssh-tunnel"><a href="#使用ssh-tunnel" class="headerlink" title="使用ssh tunnel"></a>使用ssh tunnel</h2><h3 id="win10安装ssh"><a href="#win10安装ssh" class="headerlink" title="win10安装ssh"></a>win10安装ssh</h3><p>可选择安装openSSH或者通过WSL/cygwin安装SSH<br>参考: <a href="http://www.win10.one/jc/6606.html" target="_blank" rel="noopener">http://www.win10.one/jc/6606.html</a></p><h3 id="建立ssh-tunnel"><a href="#建立ssh-tunnel" class="headerlink" title="建立ssh tunnel"></a>建立ssh tunnel</h3><p>运行命令 <code>ssh -NfL PRIVATE_PORT​:TARGET_SERVER​:22 USER_NAME​@LOGIN_SERVER​​</code><br>示例 <code>ssh -NfL 8888:10.225.1.1:22 zhangsan@10.225.2.2</code><br>解释:  </p><ol><li>PRIVATE_PORT​ 端口号,注意不能重复,可以尽量给大一点</li><li>TARGET_SERVER​ 目标centos7机器的地址,vscode连接后将在此服务器运行</li><li>LOGIN_SERVER​​ 版本为centos6的登录节点的地址,仅作为跳板使用</li></ol><h3 id="vscode配置"><a href="#vscode配置" class="headerlink" title="vscode配置"></a>vscode配置</h3><p>在Remote插件进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host login</span><br><span class="line">  HostName localhost</span><br><span class="line">  Port 8888</span><br><span class="line">  User zhangsan</span><br><span class="line">  IdentityFile C:\Users\zhangsan\.ssh\id_rsa</span><br></pre></td></tr></table></figure><p>这样就可以通过输入login这个代号进行远程连接了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;vscode有远程开发功能,即可以在windows打开vscode,连接上linux服务器写代码&lt;br&gt;但由于公司集群登录节点是centos
      
    
    </summary>
    
    
    
      <category term="vscode" scheme="http://yoursite.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>调试JS代码</title>
    <link href="http://yoursite.com/2020/07/05/js-debug/"/>
    <id>http://yoursite.com/2020/07/05/js-debug/</id>
    <published>2020-07-05T14:04:01.000Z</published>
    <updated>2020-07-05T14:35:23.784Z</updated>
    
    <content type="html"><![CDATA[<p>记录下近期对JS代码的调试过程</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>启动程序之后,打开google浏览器对应页面,按F12或者Ctrl+Shift+I进入 <strong>开发者工具页面</strong></p><p>目前主要使用的功能有:</p><ol><li><p>Performance. 性能评估,比如我想看下页面刷新的性能瓶颈所在,先点击 <em>Record</em> 按钮,然后进行页面操作,当页面刷新完成,再点击 <em>Stop</em> 按钮,则会生成性能报告,可以看到资源消耗,JS代码的执行逻辑等</p></li><li><p>Sources. 性能报告页面的 <em>Main</em> 部分,可以通过点击色块查看其所在的js代码文件,如 <em>react-xx.js</em> 点击则会跳转到 <strong>Sources</strong> 功能栏,有了源文件就可以进行断点调试;这里注意部分js文件是压缩后的文件,建议手动修改程序替换成可读性更强的原始代码文件,方便调试</p></li><li><p>Console. 查看程序的打印输出,比如我想知道某个函数的执行时间,可以在js代码中进行修改</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"foo"</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><p> 当js代码执行之后,可以在console输出中看到foo的执行时间</p></li><li><p>Network. 查看文件传输的时间,判断下瓶颈是否在网络带宽,以及是否数据量太大导致数据的转换和传输耗时较久</p></li></ol><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>通过性能分析,发现耗时最长的模块的操作是对数据的颜色计算,场景是我有1M个点需要显示,那么需要将它们从一个[2,1,4,10…]的 <em>颜色数组</em> 转换成RGB表示,js代码使用for循环进行操作,也就是线性复杂度,计算耗时随数据量的增大而线性增大</p><p>通过debug观察发现颜色数组会有不少重复的数值,而同样的输入会导致相同的输出,然后对整个数据的1M个点进行统计分析,发现重复率相当高,也就是for循环中有大量的重复计算</p><p>很自然想到增加缓存,用空间换时间来加速,当遇到计算过的数据时,直接返回计算结果,从而大大提高了程序执行的效率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[colorIn[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        colorOut[i] = cache[colorIn[i]];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    colori = getColor(colorIn, i);</span><br><span class="line">    opacityi = getOpacity(opacityIn, i);</span><br><span class="line">    colorOut[i] = calculateColor(colori, opacityi);</span><br><span class="line">    cache[colorIn[i]] = colorOut[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下近期对JS代码的调试过程&lt;/p&gt;
&lt;h2 id=&quot;性能分析&quot;&gt;&lt;a href=&quot;#性能分析&quot; class=&quot;headerlink&quot; title=&quot;性能分析&quot;&gt;&lt;/a&gt;性能分析&lt;/h2&gt;&lt;p&gt;启动程序之后,打开google浏览器对应页面,按F12或者Ctrl+Shift
      
    
    </summary>
    
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>职级晋升答辩</title>
    <link href="http://yoursite.com/2020/06/07/rank-promotion/"/>
    <id>http://yoursite.com/2020/06/07/rank-promotion/</id>
    <published>2020-06-07T02:03:30.000Z</published>
    <updated>2020-06-07T02:44:01.910Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间参加了公司的职级晋升答辩,这里结合知乎回答和个人经验,简单总结下</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>明确职级晋升答辩的目的:</p><blockquote><p>规定时间内,通过ppt精准阐述你能达到下一个职级的理由</p></blockquote><p>有资格参加答辩,说明本身产出和业绩是ok的,但这只与绩效有关,晋升关注的是<strong>能力层级</strong><br>因此需要在有限时间内,讲清楚为什么你达到了更高层级的要求,产出只是为了说明达到了要求的具体案例支撑</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>自我介绍之后,描述下自己在项目中负责的模块(可使用业务整体的架构图)</p><p>分析业务现状,趋势及挑战-&gt;明确核心路径或打法-&gt;拆分问题</p><p>对每一个问题:<br>现状与难点-&gt;解决思路-&gt;做了哪些核心工作-&gt;对应的产出如何</p><p>按照这个思路来总结自己的工作成果,自己要把逻辑理顺,然后拆分逻辑到每一页ppt中,并进行答辩讲解准备</p><h2 id="ppt制作"><a href="#ppt制作" class="headerlink" title="ppt制作"></a>ppt制作</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>使用公司模板即可;如果没有模板,选择偏严肃些的背景,无需进行过多风格创作</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>注意下中文排版格式:</p><ul><li>空格的应用</li><li>英文大小写符合规范且统一</li><li>符号应用正确</li></ul><p>文字精炼,关键词可考虑<strong>高亮加粗</strong></p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>图表很重要,尽量每一页都能有;减少文字堆积,换成简洁的图表</p><p>项目总结部分,可以加架构图,或者业务图,或者产品展示图</p><p>具体成果,一般都可以加优化前后对比图或者表格</p><p>专利软著,可以截图文章标题部分</p><h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><p>ppt结尾一般会有个人的计划,可从以下方面考虑:</p><ul><li>公司项目或产品技术方案的优化</li><li>思考怎么打造更高效的团队</li><li>工程师在行业内如何发展</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ppt 尽量精炼,多展示结果,由人来简单讲解过程;把具体细节留到评委问答环节</p><p>提前准备好评委可能问到的问题,回答过问题可以主动延伸一下,自己掌握节奏,另外可以有效拖延时间,降低被问到刁钻问题的概率</p><h2 id="ppt讲解"><a href="#ppt讲解" class="headerlink" title="ppt讲解"></a>ppt讲解</h2><blockquote><p>STAR法则<br>情景(Situation)+任务(Task)+行动(Action)+结果(Result)<br>一种结构化的描述方式,能让你的阐述更有层次性和逻辑性</p></blockquote><ol><li>情景<ul><li>业务背景</li><li>非常简要</li></ul></li><li>任务<ul><li>承担的任务或职责</li><li>遇到的问题,挑战,难点</li></ul></li><li>行动<ul><li>为了达成目标,如何展开行动的,采取了哪些措施来解决问题</li><li>讲清楚思路,做了哪些核心操作即可,细节等着提问环节回答</li></ul></li><li>结果<ul><li>最终结果如何,包括业务的,技术的,团队的</li><li>自己的总结和反思</li><li>(如果从现在的角度回去审视这件事,你会有哪些不一样的做法)-评委爱问的问题</li></ul></li></ol><p>一句话总结: <em>什么背景下,遇到了什么痛点,我的思路是怎么样的,具体做了哪些重要的事,最终结果如何?</em></p><p>例如:随着数据通量的提高,软件面临速度方面的挑战,我通过进行性能瓶颈分析,并针对性的进行xxx的优化,使程序性能提高xx倍,从而达到了产品发布的速度要求,提高了产品竞争力.</p><h2 id="逐字稿"><a href="#逐字稿" class="headerlink" title="逐字稿"></a>逐字稿</h2><p>重要的演讲,提前做好逐字稿(防止打断之后漏掉核心内容)<br>逐字稿就是把将要讲的内容,具体到每一个字写出来,相当于背稿子,可以有效提高熟练度,减少紧张感</p><p>我是将逐字稿使用markdown 格式写好,然后转pdf 打印出来,找个安静的环境进行全文阅读并背诵;使用markdown 好处是可以自己标注重点,哪里是过渡等</p><p>由于时间有限,如5min, 并且现场很可能有人掐着时间,因此务必提前多次演练,熟能生巧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间参加了公司的职级晋升答辩,这里结合知乎回答和个人经验,简单总结下&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;明确职级晋升答辩的目的:&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>读&lt;富爸爸,穷爸爸&gt;</title>
    <link href="http://yoursite.com/2020/05/13/rich-dad/"/>
    <id>http://yoursite.com/2020/05/13/rich-dad/</id>
    <published>2020-05-13T13:16:19.000Z</published>
    <updated>2020-05-13T13:41:44.551Z</updated>
    
    <content type="html"><![CDATA[<p><strong>老鼠赛跑游戏</strong>:通过学习会计和投资知识,跳出”努力工作,提高收入的同时支出也随之提高”的陷阱</p><p><strong>现状</strong>:学校教育专注于学术知识和专业技能,忽视了理财技能的培养</p><p>核心:</p><ol><li><p>穷人和中产阶级为钱工作,富人不为钱工作</p><p>单靠工作来挣工资,很难财务自由;不断用头脑思考,不求回报地工作,有可能发现比拿工资更快的挣钱方式,因为会看到别人看不到的机会<br>掌握自己的财务,让钱为我所用,就算不工作,依然能产生收益,自动增长</p></li><li><p>规则:明白资产和负债的区别,并购买资产  </p><p>资产就是能把钱放进口袋的东西,负债就是把钱从口袋拿走的东西<br>想消费的时候,先增加资产项,让它产生的现金流来给自己买单</p></li><li><p>关注自己的事业</p><p>职业的重心是收入项;事业的重心是资产项<br>关注自己的事业,在继续工作的时候不断构建资产项,而不是负债或者一旦买回家就没有价值的个人物品<br>资产分类:</p><ul><li>不需要人到场就可以正常运作的业务. 我拥有它们,但由别人经营和管理</li><li>股票</li><li>债券</li><li>共同基金</li><li>能够产生收入的房地产. 如出租,出售</li><li>票据(借据)</li><li>版税. 如音乐,手稿,专利</li><li>其他任何有价值,可产生收入或具有增值潜力并且很好销路的东西</li></ul></li><li><p>关于公司和税收  </p><p>海上贸易兴盛时,富人通过创办公司来分担每次航行的风险<br>税收初衷是为了惩罚富人,但最终是中产阶级在支付税金<br>资本家利用公司来避税:企业所得税低于个人所得税,可以用税前收入进行支出</p></li><li><p>知识储备  </p><ul><li><p>基础  </p><ul><li>会计. 财务知识</li><li>投资. 钱生钱</li><li>了解市场. 供给与需求的科学</li><li>法律. 合理减税,以及诉讼中获得保护  </li></ul></li><li><p>高级</p><ul><li>如何寻找其他人都忽视的机会</li><li>如何增加资金. 寻找银行贷款之外的方式</li><li>如何把聪明人组织起来. 当你需要建议的时候,一定要选择明智的顾问</li></ul></li><li><p>管理能力</p><ul><li>对现金流的管理</li><li>对系统(包括自己,时间及家庭)的管理</li><li>对人员的管理</li></ul></li><li><p>其他</p><ul><li>销售和市场营销</li></ul></li></ul></li><li><p>克服困难</p><ul><li>恐惧心理. 害怕失败和挫折</li><li>愤世嫉俗. 要消除外界噪音,关注自己想要的东西</li><li>懒惰</li><li>不良习惯. 如学会先支付自己</li><li>自负. 切忌傲慢自大,对某问题有欠缺,应该找领域专家或专业书籍来教育自己</li></ul></li><li><p>开始行动</p><ul><li>发掘内心想要和不想要的</li><li>做出好的选择. 投资于教育,充实头脑</li><li>慎重选择朋友. 向他人学习致富的知识</li><li>掌握一种模式. 如除了工作之外的挣钱模式</li><li>给经纪人优厚的报酬. 为专业服务付费</li><li>先给予再获取</li><li>模仿和学习偶像</li></ul></li><li><p>实践</p><ul><li>停下手头的活,评估哪些有效</li><li>向有经验的人请教. 要先付出,如请人吃饭</li><li>参与培训和辅导班</li><li>深入市场</li></ul></li></ol><p>一句话总结:</p><p><strong>通过工作产生稳定收入,同时关注自己的事业,学习财商知识,购买资产项,目标是资产收益超过日常支出,达到财务自由</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;老鼠赛跑游戏&lt;/strong&gt;:通过学习会计和投资知识,跳出”努力工作,提高收入的同时支出也随之提高”的陷阱&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现状&lt;/strong&gt;:学校教育专注于学术知识和专业技能,忽视了理财技能的培养&lt;/p&gt;
&lt;p&gt;核心:&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基因注释</title>
    <link href="http://yoursite.com/2020/04/30/gene-annotation/"/>
    <id>http://yoursite.com/2020/04/30/gene-annotation/</id>
    <published>2020-04-30T12:49:05.000Z</published>
    <updated>2020-04-30T12:59:22.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基因注释"><a href="#基因注释" class="headerlink" title="基因注释"></a>基因注释</h1><p>记录下自己对RNA-seq基因注释的学习,并对Drop-seq软件包中的注释模块进行代码研读</p><h2 id="什么是基因注释"><a href="#什么是基因注释" class="headerlink" title="什么是基因注释"></a>什么是基因注释</h2><p>一句话概况注释:<em>找到与reads有overlap的基因片段,并进行标记</em></p><p>这里reads指bam文件中的每一行数据,即测序下机文件fastq与参考基因组进行比对之后生成的数据,其中记录了每条read在参考基因组中的位置,有起始位置和终止位置,表示一段区间</p><p>基因注释文件记录了每个基因片段在参考基因组上的位置,也是一段区间,因此与bam文件结合,通过find overlapping我们可以查找到每条read属于哪个基因片段,将其标记在bam格式的tags中,这对后续的生信分析是有帮助的</p><h2 id="基因注释文件"><a href="#基因注释文件" class="headerlink" title="基因注释文件"></a>基因注释文件</h2><p>GTF/GFF格式是基因注释的常用格式<br>GTF是Gene Transfer Format的缩写,其文件由九列数据组成,以tab分割,示例如下:</p><table><thead><tr><th>seq_id</th><th>source</th><th>type</th><th>start</th><th>end</th><th>score</th><th>strand</th><th>phase</th><th>attributes</th></tr></thead><tbody><tr><td>chr1</td><td>HAVANA</td><td>exon</td><td>11869</td><td>12227</td><td>.</td><td>+</td><td>.</td><td>gene_id “ENSG00000223972.5”; transcript_id “ENST00000456328.2”;…</td></tr><tr><td>染色体编号</td><td>注释来源</td><td>类型</td><td>在参考序列的起始位置</td><td>终止位置</td><td>得分,说明注释信息的可能性</td><td>位于参考序列的正负链</td><td>仅对类型为CDS有效,表示起始编码的位置</td><td>包含众多属性的列表</td></tr></tbody></table><p>虽然数据有九列之多,但并不是所有都会用到,常用的有:</p><ol><li>seq_id. 要查找overlap,首先得是同一条染色体</li><li>type. 有多种类型,如gene/transcript/exon/CDS/UTR等,它们之间有层级关系,一般gtf文件中多行数据对应一条基因的完整信息,以type为gene的行为起始;每条gene可以表示为树状结构,gene为根节点,第二层为transcript,第三层为诸如exon CDS等</li><li>start/end. 根据起始终止位置可以建立interval,这是find overlapping的基础</li><li>strand. 正负链可以作为过滤条件,假如一条read与多个基因有overlap,可以根据方向是否相同过滤掉部分基因</li><li>attributes. 一些列键值对属性,常用的信息包括名称,id之类</li></ol><h2 id="注释流程分析"><a href="#注释流程分析" class="headerlink" title="注释流程分析"></a>注释流程分析</h2><p>流程可分为三步:</p><ol><li><strong>读入gtf文件</strong>. 从磁盘将gtf文件加载进内存,并提取需要的信息,毕竟gtf有许多信息是我们不需要的</li><li><strong>建立区间树</strong>. 即interval tree,使用区间树是为了高效查询,为了达到最佳性能,一般使用基于红黑树的区间树实现,因为红黑树是平衡树,查找时间复杂度O(lgN),不会出现退化成链表的最坏情况</li><li><strong>查找区间并注释</strong>. 遍历bam文件中每条read,根据其在参考序列中的位置构建interval,与前面建立的interval tree进行overlap的查找,找到之后,进行一些逻辑计算,并更新read的tags,输出到bam</li></ol><h2 id="Drop-seq代码研读"><a href="#Drop-seq代码研读" class="headerlink" title="Drop-seq代码研读"></a>Drop-seq代码研读</h2><p>Drop-seq是使用java开发的程序包,其中的<em>TagReadWithGeneExonFunction</em> 模块实现了添加注释的功能</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>主流程核心代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载基因注释文件,并构建区间树</span></span><br><span class="line"><span class="keyword">final</span> OverlapDetector&lt;Gene&gt; geneOverlapDetector = GeneAnnotationReader.loadAnnotationsFile(ANNOTATIONS_FILE, bamDict);</span><br><span class="line"><span class="comment">// 打开输出bam文件</span></span><br><span class="line">SAMFileWriter writer= <span class="keyword">new</span> SAMFileWriterFactory().makeSAMOrBAMWriter(header, <span class="keyword">true</span>, OUTPUT);</span><br><span class="line"><span class="comment">// 遍历输入bam中的每条read</span></span><br><span class="line"><span class="keyword">for</span> (SAMRecord r: inputSam) &#123;</span><br><span class="line">    <span class="comment">// 对完成比对的read,进行find overlapping操作并添加注释</span></span><br><span class="line">    <span class="keyword">if</span> (!r.getReadUnmappedFlag())</span><br><span class="line">        r=setAnnotations(r, geneOverlapDetector);</span><br><span class="line">    <span class="comment">// 输出注释后的read</span></span><br><span class="line">    writer.addAlignment(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果是根据overlap的genes信息,添加三个Tag,示例:</p><blockquote><p>GE:Z:WASH7P    XF:Z:CODING        GS:Z:-</p></blockquote><ul><li>GE为gene name  </li><li>XF为locus function  </li><li>GS为正负链</li></ul><h3 id="加载gtf并构建interval-tree"><a href="#加载gtf并构建interval-tree" class="headerlink" title="加载gtf并构建interval tree"></a>加载gtf并构建interval tree</h3><p>核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来解析gtf每行数据,提取需要的字段</span></span><br><span class="line"><span class="keyword">final</span> FilteringGTFParser parser = <span class="keyword">new</span> FilteringGTFParser(gtfFlatFile);</span><br><span class="line"><span class="comment">// gene name相同的gtf行,代表它们是一个gene的数据,使用它们构建GeneFromGTF数据类型,</span></span><br><span class="line"><span class="comment">// 此类型继承自Interval类型</span></span><br><span class="line"><span class="keyword">final</span> GeneFromGTFBuilder geneBuilder = <span class="keyword">new</span> GeneFromGTFBuilder(parser);</span><br><span class="line"><span class="comment">// 初始化interval tree</span></span><br><span class="line"><span class="keyword">final</span> OverlapDetector&lt;GeneFromGTF&gt; overlapDetector = <span class="keyword">new</span> OverlapDetector&lt;&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (geneBuilder.hasNext())&#123;</span><br><span class="line">        <span class="comment">// 将每条gene添加到interval tree,其内部按照chromosome进行分类</span></span><br><span class="line">        GeneFromGTF gene = geneBuilder.next();</span><br><span class="line">        overlapDetector.addLhs(gene, gene);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码实现使用了迭代器,减少内存的消耗</p><p>将gtf每行数据以gene_name为key,放入<code>map&lt;gene_name, List&lt;GTFRecord&gt;&gt;</code>中,这样就将每条gene的数据分类好了<br>geneBuilder 是个<code>iter&lt;List&lt;GTFRecord&gt;&gt;</code>,迭代时,对每个gene将其数据<code>List&lt;GTFRecord&gt;</code> 按gene_version分类成<code>map&lt;gene_version, List&lt;GTFRecord&gt;&gt;</code>,对key也就是所有的gene_version进行排序,取最大的gene_version对应的<code>List&lt;GTFRecord&gt;</code>来构建GeneFromGTF(对部分gtf文件它们的gene_version是null,则对gene_version分类和没做一样)</p><p>重点是构建GeneFromGTF类实例:<br><code>List&lt;GTFRecord&gt;</code>转GeneFromGTF调用接口<code>makeGeneFromMultiVersionGTFRecords()</code></p><ol><li>使用list中第一条GTFRecord的信息初始化GeneFromGTF(因为第一条的类型永远是gene),只有start end属性是取得list中所有数据的最小start,最大end  </li><li>进行一致性检查. 检查list中所有数据,如正反链必须都一致,chr一致等,否则抛出异常</li><li>将所有的非gene数据进行统计处理,更新GeneFromGTF成员变量<code>Map&lt;String, TranscriptFromGTF&gt; transcripts</code>, TranscriptFromGTF类型包括transcript, CDS, coding等相关信息</li></ol><p>最后调用<em>htsjdk</em>库的<code>OverlapDetector.addLhs()</code>将GeneFromGTF作为节点加入线段树中</p><h3 id="注释逻辑"><a href="#注释逻辑" class="headerlink" title="注释逻辑"></a>注释逻辑</h3><p>核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SAMRecord <span class="title">setAnnotations</span> <span class="params">(<span class="keyword">final</span> SAMRecord r, <span class="keyword">final</span> OverlapDetector&lt;Gene&gt; geneOverlapDetector)</span> </span>&#123;</span><br><span class="line">        Map&lt;Gene, LocusFunction&gt; map = AnnotationUtils.getInstance().getLocusFunctionForReadByGene(r, geneOverlapDetector);</span><br><span class="line">        Set&lt;Gene&gt; exonsForRead = AnnotationUtils.getInstance().getConsistentExons (r, map.keySet(), ALLOW_MULTI_GENE_READS);</span><br><span class="line"></span><br><span class="line">        List&lt;Gene&gt; genes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Gene g: exonsForRead) &#123;</span><br><span class="line">            LocusFunction f = map.get(g);</span><br><span class="line">            <span class="keyword">if</span> (f==LocusFunction.CODING || f==LocusFunction.UTR)</span><br><span class="line">                genes.add(g);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;LocusFunction&gt; allPassingFunctions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (USE_STRAND_INFO) &#123;</span><br><span class="line">            <span class="comment">// constrain gene exons to read strand.</span></span><br><span class="line">            genes = getGenesConsistentWithReadStrand(genes, r);</span><br><span class="line">            <span class="comment">// only retain functional map entries that are on the correct strand.</span></span><br><span class="line">            <span class="keyword">for</span> (Gene g: map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> strandCheck=readAnnotationMatchStrand(g, r);</span><br><span class="line">                <span class="keyword">if</span> (strandCheck) allPassingFunctions.add(map.get(g));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            allPassingFunctions=<span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if strand tag is used, only add locus function values for passing genes.</span></span><br><span class="line">        <span class="keyword">for</span> (Gene g: genes)</span><br><span class="line">            allPassingFunctions.add(map.get(g));</span><br><span class="line"></span><br><span class="line">        LocusFunction f = AnnotationUtils.getInstance().getLocusFunction(allPassingFunctions, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (genes.size()&gt;<span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.ALLOW_MULTI_GENE_READS==<span class="keyword">false</span>)</span><br><span class="line">            log.error(<span class="string">"There should only be 1 gene assigned to a read for DGE purposes."</span>);</span><br><span class="line"></span><br><span class="line">        String finalGeneName = getCompoundGeneName(genes);</span><br><span class="line">        String finalGeneStrand = getCompoundStrand(genes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f!=<span class="keyword">null</span>)</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.FUNCTION_TAG, f.toString());</span><br><span class="line">        <span class="keyword">if</span> (finalGeneName!=<span class="keyword">null</span> &amp;&amp; finalGeneStrand!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.TAG, finalGeneName);</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.STRAND_TAG, finalGeneStrand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.TAG, <span class="keyword">null</span>);</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.STRAND_TAG, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>概况一下注释逻辑:对read构建interval,查找overlap的所有基因,计算三个tag: locusFunction, geneName, geneStrand,并更新read  </p><p>对每个gene计算locusFunction的核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LocusFunction <span class="title">getLocusFunctionForRead</span> <span class="params">(<span class="keyword">final</span> SAMRecord rec, <span class="keyword">final</span> Gene g)</span> </span>&#123;</span><br><span class="line">    List&lt;AlignmentBlock&gt; alignmentBlocks = rec.getAlignmentBlocks();</span><br><span class="line"></span><br><span class="line">    LocusFunction [] blockSummaryFunction = <span class="keyword">new</span> LocusFunction[alignmentBlocks.size()];</span><br><span class="line">    Set&lt;Gene&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    temp.add(g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;alignmentBlocks.size(); i++) &#123;</span><br><span class="line">        AlignmentBlock alignmentBlock =alignmentBlocks.get(i);</span><br><span class="line"></span><br><span class="line">        LocusFunction [] blockFunctions=getLocusFunctionsByBlock(alignmentBlock, temp);</span><br><span class="line">        LocusFunction blockFunction = getLocusFunction(blockFunctions, <span class="keyword">false</span>);</span><br><span class="line">        blockSummaryFunction[i]=blockFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocusFunction readFunction = getLocusFunction(blockSummaryFunction, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> readFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算过程:</p><ol><li>对read每个位点都计算一个LocusFunction(计算过程具体为是否与exons有overlap)</li><li>将一条alignmentBlocks中所有位点的LocusFunctions合并为一个LocusFunction</li><li>将所有alignmentBlocks的LocusFunctions合并为一个LocusFunction</li></ol><p>每次合并都是取最大的LocusFunction,其是一个枚举变量,由小到大为:<br><code>INTERGENIC, INTRONIC, UTR, CODING, RIBOSOMAL</code></p><h3 id="输出统计信息"><a href="#输出统计信息" class="headerlink" title="输出统计信息"></a>输出统计信息</h3><table><thead><tr><th>统计项</th><th>解释</th></tr></thead><tbody><tr><td>AMBIGUOUS_READS_REJECTED</td><td>有多条同方向的overlaped gene</td></tr><tr><td>READ_AMBIGUOUS_GENE_FIXED</td><td>overlaped gene中同向的只有一条,但是还有反向的</td></tr><tr><td>READS_RIGHT_STRAND</td><td>只有一条overlaped gene,并且与read同向</td></tr><tr><td>READS_WRONG_STRAND</td><td>overlaped gene没有同向,只有反向</td></tr><tr><td>TOTAL_READS</td><td>处理的总reads数</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/sinat_38163598/article/details/72851239" target="_blank" rel="noopener">GTF基因注释文件详解</a></li><li><a href="https://www.jianshu.com/p/0800a07cfa37" target="_blank" rel="noopener">液滴微流控获取单细胞及Drop-seq_tools分析流程</a></li><li><a href="https://github.com/broadinstitute/Drop-seq" target="_blank" rel="noopener">Drop-seq_github</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基因注释&quot;&gt;&lt;a href=&quot;#基因注释&quot; class=&quot;headerlink&quot; title=&quot;基因注释&quot;&gt;&lt;/a&gt;基因注释&lt;/h1&gt;&lt;p&gt;记录下自己对RNA-seq基因注释的学习,并对Drop-seq软件包中的注释模块进行代码研读&lt;/p&gt;
&lt;h2 id=&quot;什么是
      
    
    </summary>
    
    
    
      <category term="基因注释" scheme="http://yoursite.com/tags/%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>seqan库的使用</title>
    <link href="http://yoursite.com/2020/04/26/intro-seqan/"/>
    <id>http://yoursite.com/2020/04/26/intro-seqan/</id>
    <published>2020-04-26T12:40:41.000Z</published>
    <updated>2020-04-26T12:56:00.942Z</updated>
    
    <content type="html"><![CDATA[<p>seqan库是进行生物序列分析的一个现代的C++库,目前有seqan2, seqan3两个版本,seqan3正在开发当中<br>我打算应用seqan库实现一个简单的注释程序,因为seqan3暂时还未实现gtf文件的相关操作,因此选用seqan2  </p><p>seqan是header-only的库,因此无需添加lib,只要包含头文件即可使用  </p><h2 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h2><p>为了使用简洁,定义常用类型的别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> seqan::FragmentStore&lt;&gt; TStore;</span><br><span class="line"><span class="keyword">typedef</span> seqan::Value&lt;TStore::TAnnotationStore&gt;::Type TAnnotation;</span><br><span class="line"><span class="keyword">typedef</span> TAnnotation::TId TId;</span><br><span class="line"><span class="keyword">typedef</span> TAnnotation::TPos TPos;</span><br><span class="line"><span class="keyword">typedef</span> seqan::IntervalAndCargo&lt;TPos, TId&gt; TInterval;</span><br><span class="line"><span class="keyword">typedef</span> seqan::IntervalTree&lt;TPos, TId&gt; TIntervalTree;</span><br><span class="line"><span class="keyword">typedef</span> seqan::String&lt;TIntervalTree&gt; TIntervalTrees;</span><br><span class="line"><span class="keyword">typedef</span> seqan::Iterator&lt;TStore <span class="keyword">const</span>, seqan::AnnotationTree&lt;&gt; &gt;::Type TCIterator;</span><br><span class="line"><span class="keyword">typedef</span> seqan::Iterator&lt;TStore, seqan::AnnotationTree&lt;&gt; &gt;::Type TIterator;</span><br><span class="line"><span class="keyword">typedef</span> seqan::String&lt;TId&gt; TIds;</span><br><span class="line"><span class="keyword">typedef</span> seqan::BamAlignmentRecord BamRecord;</span><br></pre></td></tr></table></figure><h2 id="gtf文件的加载"><a href="#gtf文件的加载" class="headerlink" title="gtf文件的加载"></a>gtf文件的加载</h2><p>直接上代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seqan::FragmentStore&lt;&gt; store;</span><br><span class="line">seqan::GffFileIn annotationFile;</span><br><span class="line"><span class="keyword">if</span> (!seqan::open(annotationFile, gtf_file.c_str()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">readRecords(store, annotationFile);</span><br></pre></td></tr></table></figure><p>可以看到,只要几行代码就将gtf文件的数据读取到内存中;使用FragmentStore来管理内存</p><p>gtf数据在内存中的存储,可以被视为关系型数据库,每一行表示一个gene,因此通过唯一ID可以访问gene数据,而gene数据是树状结构,如下图:<br><img src="/images/intro_seqan/seqan-annotation-store.png" alt="seqan-annotation-store"></p><p>想要遍历gtf数据,首先拿到根节点迭代器,然后使用树的遍历方式即可</p><h2 id="构建interval-tree"><a href="#构建interval-tree" class="headerlink" title="构建interval tree"></a>构建interval tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">seqan::String&lt;seqan::String&lt;TInterval&gt;&gt; intervals;</span><br><span class="line"><span class="keyword">int</span> numContigs = seqan::length(store.contigStore);</span><br><span class="line">resize(intervals, numContigs);</span><br><span class="line"></span><br><span class="line">TIterator it = seqan::begin(store, seqan::AnnotationTree&lt;&gt;());</span><br><span class="line"><span class="keyword">if</span> (!goDown(it))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    SEQAN_ASSERT_EQ(getType(it), <span class="string">"gene"</span>);</span><br><span class="line">    TPos beginPos = getAnnotation(it).beginPos;</span><br><span class="line">    TPos endPos = getAnnotation(it).endPos;</span><br><span class="line">    TId contigId = getAnnotation(it).contigId;</span><br><span class="line">    <span class="keyword">if</span> (beginPos &gt; endPos)</span><br><span class="line">        <span class="built_in">std</span>::swap(beginPos, endPos);</span><br><span class="line">    appendValue(intervals[contigId], TInterval(beginPos, endPos, value(it)));</span><br><span class="line">&#125; <span class="keyword">while</span> (goRight(it));</span><br><span class="line"></span><br><span class="line">TIntervalTrees intervalTrees;</span><br><span class="line">resize(intervalTrees, numContigs);</span><br><span class="line"></span><br><span class="line">SEQAN_OMP_PRAGMA(parallel <span class="keyword">for</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numContigs; ++i)</span><br><span class="line">    seqan::createIntervalTree(intervalTrees[i], intervals[i]);</span><br></pre></td></tr></table></figure><p>要构建线段树intervalTrees,首先得有一组线段intervals.通过遍历gtf数据,对每个gene构建一个interval,加入intervals,这里注意chromosome之间无关联,应分别建立数据;最后通过createIntervalTree接口构建intervalTrees,利用chromosome之间独立的特性,使用openmp加速构建过程</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开输入bam</span></span><br><span class="line">seqan::BamFileIn inFile;</span><br><span class="line">seqan::open(inFile, inputBamFilename.c_str());</span><br><span class="line">seqan::BamHeader header;</span><br><span class="line">seqan::readHeader(header, inFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开输出bam,注意初始化header</span></span><br><span class="line">seqan::BamFileOut fileOut;</span><br><span class="line">fileOut.context = seqan::context(inFile);</span><br><span class="line">seqan::setFormat(fileOut, seqan::Bam());</span><br><span class="line">seqan::open(fileOut, outputBamFilename.c_str(), seqan::OPEN_WRONLY |seqan::OPEN_CREATE);</span><br><span class="line">seqan::writeHeader(fileOut, header);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历bam中每条read</span></span><br><span class="line"><span class="keyword">while</span> (!seqan::atEnd(inFile))</span><br><span class="line">&#123;</span><br><span class="line">    seqan::readRecord(record, inFile);</span><br><span class="line">    TPos queryBegin = record.beginPos+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里是根据read的cigar信息计算出长度,省略部分代码</span></span><br><span class="line">    TPos queryEnd = queryBegin + getReferenceLength(record.cigar);</span><br><span class="line"></span><br><span class="line">    TIds result;</span><br><span class="line">    <span class="keyword">if</span> (record.rID &lt; seqan::length(intervalTrees))</span><br><span class="line">        seqan::findIntervals(result, intervalTrees[record.rID], queryBegin, queryEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *result记录了与当前read有overlap的gene在数据库中的唯一ID,由于计算逻辑实现过长</span></span><br><span class="line"><span class="comment">    *接下来省略对locusFunction等的计算代码,result的使用简略记录下,通过迭代器访问原始gtf数据</span></span><br><span class="line"><span class="comment">    *TIterator it;</span></span><br><span class="line"><span class="comment">    *for (unsigned j = 0; j &lt; seqan::length(result); ++j)</span></span><br><span class="line"><span class="comment">    *&#123;</span></span><br><span class="line"><span class="comment">    *   int id = result[j];</span></span><br><span class="line"><span class="comment">    *   goTo(it, id);</span></span><br><span class="line"><span class="comment">    *   ...</span></span><br><span class="line"><span class="comment">    *&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新read的tag信息,示例会生成tag信息: GE:Z:gene_name (中间的Z表示value为字符串)</span></span><br><span class="line">    <span class="function">seqan::BamTagsDict <span class="title">tags</span><span class="params">(record.tags)</span></span>;</span><br><span class="line">    seqan::setTagValue(tags, <span class="string">"GE"</span>, <span class="string">"gene_name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出bam</span></span><br><span class="line">    seqan::writeRecord(fileOut, record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的注释逻辑自然实现不同,所以这里仅给出代码结构,更多细节要多阅读seqan库的文档,还是挺详细的</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>一些预定义宏可能有加速效果</p><ul><li>SEQAN_ASYNC_IO=1 允许异步输入输出操作</li><li>SEQAN_BGZF_NUM_THREADS=value 读写bam文件使用的线程数</li></ul><p>其他的就是使用性能分析工具如valgrind,gprof等找出瓶颈并针对性优化</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><p>Q:error MSB8036: The Windows SDK version 8.1 was not found<br>A:控制面板-应用程序-修改vs studio-勾选上通用工具中的win10SDK,重新安装</p><p>Q:No CMAKE_CXX_COMPILER could be found<br>A:删掉缓存,重新编译</p><p>Q:windows下的项目配置<br>A:配置属性-C/C++-语言 复合模式选择否,启用运行时类型信息选择是(/GR) OpenMP支持选择是;字符集选择多字节字符集;警告等级选择/W2;添加zlib,用于读取bam文件,注意x86和x64不要搞混</p><p>Q:预处理设置<br>A:</p><blockquote><p>WIN32_WINDOWS<br>SEQAN_ENABLE_DEBUG=1<br>SEQAN_GLOBAL_EXCEPTION_HANDLER=1<br><em>WIN32_WINNT=0x0600<br>WINVER=0x0600<br>_SCL_SECURE_NO_WARNINGS<br>_CRT_SECURE_NO_WARNINGS<br>NOMINMAX<br>SEQAN_HAS_EXECINFO=0<br>SEQAN_HAS_OPENMP=1<br>SEQAN_APP_VERSION=”1.5.8”<br>SEQAN_REVISION=”f5f6583”<br>SEQAN_DATE=”2019-08-02_14:42:28</em>+0000”<br>CMAKE_INTDIR=”Debug”  </p></blockquote><h3 id="代码错误"><a href="#代码错误" class="headerlink" title="代码错误"></a>代码错误</h3><p>Q:getValueByKey接口调用异常<br>A:修改代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释掉此接口</span></span><br><span class="line"><span class="comment">//template &lt;typename TFragmentStore, typename TSpec, typename TKey&gt;</span></span><br><span class="line"><span class="comment">//inline CharString</span></span><br><span class="line"><span class="comment">//getValueByKey(</span></span><br><span class="line"><span class="comment">//    Iter&lt;TFragmentStore, AnnotationTree&lt;TSpec&gt; &gt; const &amp; it,</span></span><br><span class="line"><span class="comment">//    TKey const &amp; key)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    return annotationGetValueByKey(*it.store, getAnnotation(it), key);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FragmentStore&lt;TSpec, TConfig&gt; &amp; fragStore, 参数加const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TSpec, <span class="keyword">typename</span> TConfig, <span class="keyword">typename</span> TAnnotation, <span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">annotationGetValueByKey (</span><br><span class="line">    TValue &amp; value,</span><br><span class="line">    FragmentStore&lt;TSpec, TConfig&gt; <span class="keyword">const</span> &amp; fragStore,</span><br><span class="line">    TAnnotation <span class="keyword">const</span> &amp; annotation,</span><br><span class="line">    TKey <span class="keyword">const</span> &amp; key)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.seqan.de/" target="_blank" rel="noopener">seqan官网</a></li><li><a href="https://github.com/seqan/seqan" target="_blank" rel="noopener">github仓库</a></li><li><a href="http://docs.seqan.de/seqan/master/" target="_blank" rel="noopener">API文档</a></li><li><a href="https://seqan.readthedocs.io/en/master/Tutorial/HowTo/UseCases/SimpleRnaSeq.html" target="_blank" rel="noopener">Simple RNA-Seq</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;seqan库是进行生物序列分析的一个现代的C++库,目前有seqan2, seqan3两个版本,seqan3正在开发当中&lt;br&gt;我打算应用seqan库实现一个简单的注释程序,因为seqan3暂时还未实现gtf文件的相关操作,因此选用seqan2  &lt;/p&gt;
&lt;p&gt;seqan
      
    
    </summary>
    
    
    
      <category term="seqan 基因注释" scheme="http://yoursite.com/tags/seqan-%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>linux进行c++开发经验总结</title>
    <link href="http://yoursite.com/2020/04/12/linux-cpp/"/>
    <id>http://yoursite.com/2020/04/12/linux-cpp/</id>
    <published>2020-04-12T14:37:45.000Z</published>
    <updated>2020-04-12T15:24:59.438Z</updated>
    
    <content type="html"><![CDATA[<p>这一周主要就是在linux下进行c++的开发,以此为契机记录下遇到的问题.</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>使用<strong>git</strong>管理源代码</p><p>常用命令包括:<em>clone pull push commit checkout branch tag log</em> 等</p><h3 id="拉取代码报错"><a href="#拉取代码报错" class="headerlink" title="拉取代码报错"></a>拉取代码报错</h3><p>git 1.7版本拉去代码报错:<br><em>error: The requested URL returned error: 401 Unauthorized while accessing</em><br>解决方案:升级最新版本git<br>有时候拉取代码不成功,可以ssh/https两种链接都试试</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>vim进行临时的一些修改,vscode用于较大的项目,VS Studio用于windows下的调试  </p><p>目前主要使用<strong>vscode</strong>,开发环境是无界面的linux系统,使用最新版本的vscode有连远程代码仓库的功能,可以在本地windows进行远程代码修改</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>简单的工程可以一条gcc命令进行编译,较大的项目还是使用cmake更好一些  </p><p>使用<strong>cmake</strong>编译,首先编写CMakeLists.txt,然后编写脚本配置环境变量如include和library路径,再运行cmake和make命令即可完成编译</p><h3 id="查错"><a href="#查错" class="headerlink" title="查错"></a>查错</h3><p>VERBOSE模式,输出具体的gcc编译命令,方便查错,通过<code>make VERBOSE=1</code> 选项来开启模式</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以通过在CMakeLists.txt中添加预定义宏<br><em>add_definitions(-DAABB=1)</em> 来设置宏AABB值为1,或者<em>add_definitions(-DDEBUG)</em> 来打开DEBUG宏</p><h3 id="编译慢问题"><a href="#编译慢问题" class="headerlink" title="编译慢问题"></a>编译慢问题</h3><p>遇到cmake编译慢问题,通过top命令及ps命令查到自己的进程状态为<em>D</em>,查阅手册D含义是进程处于睡眠状态,也就是进程由于等待IO如磁盘IO,网络IO等,导致较长时间都没有响应<br>判断磁盘IO慢的问题,因此修改编译脚本,将编译的中间结果文件输出到临时的内存空间shm中去,编译后再删除临时文件,减少本地磁盘IO操作,从而加速编译过程</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>可以直接本地运行,方便查看占用内存和CPU资源情况,也可以使用公司集群系统投递任务,好处是统一的任务管理调度,不会出现资源竞争情况导致程序运行时间波动</p><h3 id="库版本不对"><a href="#库版本不对" class="headerlink" title="库版本不对"></a>库版本不对</h3><p><em>/lib64/libc.so.6: version `GLIBC_2.14’ not found (required by xxx)</em><br>这种情况是本地的libc库版本太旧,需要更新libc库版本</p><h3 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h3><p>一般程序会输出log到磁盘文件,想要实时监控日志文件的更新内容,可以使用<code>tail -f filename</code>命令,它会在文件内容有更新时将结果输出到命令窗口</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>使用<strong>gdb</strong>调试C++程序  </p><ol><li>编译时加 <em>-g -gstabs+</em> 选项,并且去除 <em>-O2</em> 等优化选项</li><li>两种调试方式<ol><li>直接<code>gdb ./prog</code> 进入gdb交互环境,通过命令<code>set args xxx</code>来设置参数,然后<code>r</code>来运行</li><li>通过设置,使程序挂掉时生成core文件,通过<code>gdb ./prog core.xxxx</code>来还原程序挂掉前的状态</li></ol></li></ol><p>gdb常用快捷键:</p><ul><li>bt 查看堆栈</li><li>l 查看当前所处位置的源代码</li><li>b 打断的,如<code>b filename::linenum</code> 打断点到文件的某一行,也可以直接打到某函数位置</li><li>n 下一步</li><li>c 继续运行,直到程序结束或者遇到断点</li><li>s 单步调试</li><li>r 重头运行程序</li><li>p 打印变量内容</li><li>help 查看命令提示</li></ul><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>gprof</strong>工具<br>linux上分析gcc编译出来的程序的CPU时间,找出最耗时的函数  </p><p>使用:</p><ol><li><code>gcc -pg</code> 选项编译</li><li>运行程序,结束后生成gmon.out</li><li><code>gprof ./prog gmon.out -b</code> 查看输出 </li></ol><p>原理: 在每个函数中插入count函数,这样函数调用时就会计算次数和时间<br>缺点: 无法分析多线程程序;无法观察IO时间</p><p><strong>valgrind</strong>工具<br>可以使用它的<em>Memcheck</em> 功能来进行内存检查,或者<em>Callgrind</em> 进行耗时和函数调用情况分析</p><p>使用:</p><ol><li><code>valgrind --tool=callgrind ./prog_name</code> 运行完会生成callgrind.out.xxx的文件</li><li><em>kcachegrind.exe</em> 打开上一步生成的文件,可以看到函数运行耗时,以及调用的流程图</li></ol><p>知道哪个函数或者哪个操作最耗时,再进一步分析是数据结构选型不适合还是算法没有达到最优,再进行速度提升</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周主要就是在linux下进行c++的开发,以此为契机记录下遇到的问题.&lt;/p&gt;
&lt;h2 id=&quot;版本管理&quot;&gt;&lt;a href=&quot;#版本管理&quot; class=&quot;headerlink&quot; title=&quot;版本管理&quot;&gt;&lt;/a&gt;版本管理&lt;/h2&gt;&lt;p&gt;使用&lt;strong&gt;git&lt;/st
      
    
    </summary>
    
    
    
      <category term="linux c++" scheme="http://yoursite.com/tags/linux-c/"/>
    
  </entry>
  
  <entry>
    <title>爬取英文演讲资源</title>
    <link href="http://yoursite.com/2020/04/05/scrapy-mp3/"/>
    <id>http://yoursite.com/2020/04/05/scrapy-mp3/</id>
    <published>2020-04-05T06:55:51.000Z</published>
    <updated>2020-04-05T08:01:58.716Z</updated>
    
    <content type="html"><![CDATA[<p>记录下使用python爬取网页并下载资源的过程.</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>前段时间制定计划,每天上下班路上听点英语演讲音频练练听力,用的手机App是喜马拉雅,上面资源很丰富,但是有两个问题,一是<strong>有广告</strong>,想想你快睡着的时候突然来15秒字正腔圆的广告是什么感觉,二是<strong>费流量</strong>,我都是在线听的.  </p><p>因此考虑在PC上提前下载好部分音频,导出到手机,再切换到一个精简去广告的手机App来听,岂不美哉.  </p><p>学习英语的网站有不少,也可以提供下载,但一个一个右键另存为就不符合咱程序员的身份了,因此爬虫搞起!</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>爬取之前,复习下需要的知识,当然这次任务很简单,这里只是总结下.  </p><ol><li>python基础. 如文件存取,正则表达式re,多进程multiprocessing</li><li>html网页结构. 如常见的标签tag,CSS中的class</li><li>爬虫相关的库.<ul><li>urllib. 提供接口来打开网页,下载资源</li><li>BeautifulSoup. 解析网页,提取信息</li></ul></li></ol><p>缺少哪个py库,用<code>pip install xx</code> 来安装</p><h2 id="分析与设计"><a href="#分析与设计" class="headerlink" title="分析与设计"></a>分析与设计</h2><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>人工打开几个目标网页,查看网页源代码来分析下规律,即如何通过主网页,一步步跳转到最终的资源链接.  </p><p>打开主页,上面显示几十个链接,每一个链接分别是一个具体的演讲页面,其中一个表示如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">class</span>=<span class="string">"titlepic"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/tingli/speech/mxlzyj/326635.html"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/d/file/201906/6fffc975854bf3f3136637cd69cc6397.jpg"</span> <span class="attr">alt</span>=<span class="string">"库克杜兰大学演讲：勇于尝试 敢于做先行者(全文)"</span> <span class="attr">width</span>=<span class="string">"145"</span> <span class="attr">height</span>=<span class="string">"125"</span> <span class="attr">border</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此只要匹配到align属性为’center’,class属性为[‘titlepic’]的td标签,获取第一个href即是一个演讲的链接地址<br>这里要注意给出的链接是需要补齐前缀的</p><p>针对每一个具体的演讲的网页,基本都提供了一个音频的播放器</p><p><img src="/images/scrapy_mp3/speech_player.png" alt=""></p><p>只要点击下载图标按钮,就会切换到另一个网页,内容为</p><p><img src="/images/scrapy_mp3/download_icon.png" alt=""></p><p>这里两个图标分别对应mp3和lrc歌词的资源地址</p><p>分析音频播放器下载按钮的链接,不出意料,是一个js函数,如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT type=text/javascript&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">".jp-title"</span>).hover(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).addClass(<span class="string">"jp-title-hover"</span>);</span><br><span class="line">            &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).removeClass(<span class="string">"jp-title-hover"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    $(<span class="string">".jp-title"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">".help"</span>).slideToggle();</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">".jp-download"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.open(<span class="string">'/e/action/down.php?classid=10467&amp;id=326635&amp;mp3=http://mp3.en8848.com/speech/2019tim-cook-tulane.mp3'</span>) ;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">".anniu"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">".download"</span>).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"a[id^='jplayer_tc_']"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;location.href=$(<span class="keyword">this</span>).attr(<span class="string">'href'</span>)&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/SCRIPT&gt;</span></span><br></pre></td></tr></table></figure><p>重点就是<em>window.open</em> 后的内容,指向最终下载页面的链接.<br>这里可以通过正则表达式来解析链接地址</p><p>分析最终页面,发现内容如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"dload"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://mp3.en8848.com/speech/2019tim-cook-tulane.mp3"</span> <span class="attr">class</span>=<span class="string">"download"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"dloadword"</span> <span class="attr">href</span>=<span class="string">"http://mp3.en8848.com/speech/2019tim-cook-tulane.lrc"</span> <span class="attr">class</span>=<span class="string">"download"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即mp3资源链接即是从播放器下载图标中提取出来的链接中的 <strong>mp3=xxx</strong>的地址<br>lrc歌词改下后缀即可</p><h3 id="提炼总结"><a href="#提炼总结" class="headerlink" title="提炼总结"></a>提炼总结</h3><ol><li>根据提供的主页,通过<strong>特定的td标签</strong>解析出来每一个演讲的链接,即是一个单独的任务</li><li>对每个任务,解析js中<strong>window.open</strong>后跟的链接,即是最终的资源所在;分别下载mp3和lrc即可</li></ol><h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main_url &#x3D; &quot;xxx.html&quot;</span><br><span class="line">for td_tag in main_url:</span><br><span class="line">    check if td_tag is valid</span><br><span class="line">    get speech_url from td_tag</span><br><span class="line">    extract rescource_url from speech_url</span><br><span class="line">    download resource_url+&#39;.mp3&#39; and resource_url+&#39;.lrc&#39;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-- codeding:utf-8 --</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(url, dest_dir)</span>:</span></span><br><span class="line">    speech = urllib.urlopen(url).read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    speech_soup = BeautifulSoup(speech, <span class="string">"lxml"</span>)</span><br><span class="line">    <span class="comment"># Get speech name.</span></span><br><span class="line">    speech_name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> div_tag <span class="keyword">in</span> speech_soup.find_all(<span class="string">'div'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'class'</span> <span class="keyword">in</span> div_tag.attrs <span class="keyword">and</span> div_tag[<span class="string">'class'</span>] == [<span class="string">"sean_title"</span>]:</span><br><span class="line">            speech_name = div_tag.get_text()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> speech_name == <span class="string">""</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># Remove extra spaces.</span></span><br><span class="line">    speech_name = speech_name.replace(<span class="string">" "</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span> script_tag <span class="keyword">in</span> speech_soup.find_all(<span class="string">'script'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'type'</span> <span class="keyword">in</span> script_tag.attrs <span class="keyword">and</span> script_tag[<span class="string">'type'</span>] == <span class="string">"text/javascript"</span>:</span><br><span class="line">            p = re.compile(<span class="string">r'mp3=(.*).mp3'</span>, re.DOTALL)</span><br><span class="line">            <span class="comment">#print script_tag.get_text()</span></span><br><span class="line">            match = p.findall(script_tag.get_text())</span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                urllib.urlretrieve(match[<span class="number">0</span>]+<span class="string">'.mp3'</span>, dest_dir+speech_name+<span class="string">'.mp3'</span>)</span><br><span class="line">                urllib.urlretrieve(match[<span class="number">0</span>]+<span class="string">'.lrc'</span>, dest_dir+speech_name+<span class="string">'.lrc'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrapy_map3</span><span class="params">()</span>:</span></span><br><span class="line">    origin_url = <span class="string">"http://www.en8848.com.cn/tingli/speech/mxlzyj/index.html"</span></span><br><span class="line">    prefix_url = <span class="string">"http://www.en8848.com.cn"</span></span><br><span class="line">    l = urllib.urlopen(origin_url).read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    soup = BeautifulSoup(l, <span class="string">"lxml"</span>)</span><br><span class="line">    dest_dir = <span class="string">'./speech/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest_dir): os.mkdir(dest_dir)</span><br><span class="line">    <span class="comment"># Format: &lt;td align="center"&gt;&lt;a href=xxx&gt;&lt;/td&gt;</span></span><br><span class="line">    pool = mp.Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> td_tag <span class="keyword">in</span> soup.find_all(<span class="string">'td'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'align'</span> <span class="keyword">not</span> <span class="keyword">in</span> td_tag.attrs <span class="keyword">or</span> <span class="string">'class'</span> <span class="keyword">not</span> <span class="keyword">in</span> td_tag.attrs: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> td_tag[<span class="string">'align'</span>] == <span class="string">'center'</span> <span class="keyword">and</span> td_tag[<span class="string">'class'</span>] == [<span class="string">'titlepic'</span>]:</span><br><span class="line">            url = prefix_url + td_tag.a.get(<span class="string">"href"</span>)</span><br><span class="line">            pool.apply_async(crawl, args=(url,dest_dir))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    scrapy_map3()</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>代码实现是在设计的伪码基础上填充了细节,诸如具体的判断,以及文件名的获取等未提到的细节</p><p>考虑到网页获取,文本解析,资源下载速度较慢,而每一个演讲都是独立的,可以使用多进程进行加速</p><p>除了多进程,还有异步IO,协程等方式可以加速</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.en8848.com.cn/tingli/speech/mxlzyj/index.html" target="_blank" rel="noopener">小e英语_英语演讲</a></li><li><a href="https://morvanzhou.github.io/tutorials/data-manipulation/scraping/" target="_blank" rel="noopener">莫烦python_爬虫基础</a></li><li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">BeautifulSoup4.2.0中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下使用python爬取网页并下载资源的过程.&lt;/p&gt;
&lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;前段时间制定计划,每天上下班路上听点英语演讲音频练练听力,用的手机App是喜
      
    
    </summary>
    
    
    
      <category term="爬虫 python" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB-python/"/>
    
  </entry>
  
  <entry>
    <title>vim实用技巧</title>
    <link href="http://yoursite.com/2020/03/29/vim-practical-skills/"/>
    <id>http://yoursite.com/2020/03/29/vim-practical-skills/</id>
    <published>2020-03-29T12:35:59.000Z</published>
    <updated>2020-03-29T12:41:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>记录vim实用技巧,会长期更新</p><h2 id="record-回放功能"><a href="#record-回放功能" class="headerlink" title="record 回放功能"></a>record 回放功能</h2><p>使用场景:需要多次进行的有规律但较为复杂的操作<br>步骤:</p><ol><li>q+a 开始录制</li><li>命令完成,按q停止</li><li>@+a 重复执行命令  </li></ol><p>其中a是record名字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录vim实用技巧,会长期更新&lt;/p&gt;
&lt;h2 id=&quot;record-回放功能&quot;&gt;&lt;a href=&quot;#record-回放功能&quot; class=&quot;headerlink&quot; title=&quot;record 回放功能&quot;&gt;&lt;/a&gt;record 回放功能&lt;/h2&gt;&lt;p&gt;使用场景:需要多次进行
      
    
    </summary>
    
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的压缩方式总结</title>
    <link href="http://yoursite.com/2020/03/22/compress-method/"/>
    <id>http://yoursite.com/2020/03/22/compress-method/</id>
    <published>2020-03-22T13:00:52.000Z</published>
    <updated>2020-03-22T14:23:49.053Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结工作中使用过的数据压缩方法,主要有zlib,qatzip,igzip等<br>最后还进行了针对大规模数据多线程解压缩加速的分析</p><h2 id="zlib库"><a href="#zlib库" class="headerlink" title="zlib库"></a>zlib库</h2><p>zlib是用于数据压缩的函数库,使用deflate算法<br><strong>deflate算法</strong>是同时使用了<em>LZ77算法</em>和<em>霍夫曼编码</em>的一个无损压缩算法</p><p>主要函数有:</p><ul><li><code>int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);</code><br>  压缩方法,将源缓冲中的数据压缩并放入目的缓冲区<br>  注意目的缓冲区的大小有可能比压缩前还要大,因此destLen要留够空间,至少比sourceLen加12字节之后还大0.1%<br>  返回Z_OK表示成功;Z_MEM_ERROR表示没有足够内存;Z_BUF_ERROR表示目的缓冲区不够大</li><li><code>int compress2 (Bytef *dest, uLongf *destLen,const Bytef *source, uLong sourceLen,int level);</code><br>  功能与compress函数一样,增加了level参数,范围0-9,从0-9速度变慢,但压缩率提高,设置0表示不压缩,Z_DEFAULT_COMPRESSION 表示设置一个适中的参数<br>  返回值与compress相同,多出Z_STREAM_ERROR 表示level参数无效</li><li><code>int uncompress (Bytef *dest, uLongf *destLen,const Bytef *source, uLong sourceLen);</code><br>  解压缩<br>  返回值与compress相同,多出一个Z_DATA_ERROR 表示输入数据被破坏</li><li><code>deflateInit() + deflate() + deflateEnd()</code><br>  三个函数结合完成compress功能,参考zlib仓库example.c compress.c</li><li><code>inflateInit() + inflate() + inflateEnd()</code><br>  三个函数完成uncompress功能</li><li>gz开头的函数,用来操作gz文件,类似stdio调用,如果gzopen,gzwrite等</li></ul><p>简单的压缩示例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gzCompress</span><span class="params">(Bytef *data, uLong ndata, Bytef *zdata, uLong *nzdata, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// error code </span></span><br><span class="line"><span class="comment">// Z_OK if success, Z_MEM_ERROR if there was not enough memory, </span></span><br><span class="line"><span class="comment">// Z_BUF_ERROR:-5 if there was not enough room in the output buffer, </span></span><br><span class="line"><span class="comment">// Z_STREAM_ERROR if the level parameter is invalid.</span></span><br><span class="line">z_stream c_stream;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (data &amp;&amp; ndata &gt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">c_stream.zalloc = <span class="literal">NULL</span>;</span><br><span class="line">c_stream.zfree = <span class="literal">NULL</span>;</span><br><span class="line">c_stream.opaque = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (deflateInit2(&amp;c_stream, level, Z_DEFLATED,</span><br><span class="line">MAX_WBITS + <span class="number">16</span>, <span class="number">8</span>, Z_DEFAULT_STRATEGY) != Z_OK) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">c_stream.next_in = data;</span><br><span class="line">c_stream.avail_in = ndata;</span><br><span class="line">c_stream.next_out = zdata;</span><br><span class="line">c_stream.avail_out = *nzdata;</span><br><span class="line"><span class="keyword">while</span> (c_stream.avail_in != <span class="number">0</span> &amp;&amp; c_stream.total_out &lt; *nzdata) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((err = deflate(&amp;c_stream, Z_BLOCK)) != Z_OK)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deflate error: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c_stream.avail_in != <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> c_stream.avail_in;</span><br><span class="line"><span class="keyword">for</span> (;;) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((err = deflate(&amp;c_stream, Z_FINISH)) == Z_STREAM_END) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (err != Z_OK) <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (deflateEnd(&amp;c_stream) != Z_OK) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*nzdata = c_stream.total_out;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于压缩等级,从0-9,速度越来越慢,随之而来的是更低的压缩率</p><p>压缩文件是二进制的,由三部分组成</p><ol><li>头信息</li><li>数据主体 </li><li>校验</li></ol><p>以下为标准格式的简要说明,详细解释可以看参考文档:<br><img src="/images/compress_method/header.png" alt=""></p><h2 id="qatzip库"><a href="#qatzip库" class="headerlink" title="qatzip库"></a>qatzip库</h2><p>通过硬件加速的方式进行压缩,即需要插入一张单独的intel的QAT卡;好处显而易见,正常压缩是消耗CPU资源,用另一张卡单独进行压缩,空闲出CPU资源可以进行其他计算,提高整体效率,缺点就是费钱,并占用一个PCIE插槽位置<br>另外只能运行于linux系统,不支持windows</p><p><a href="https://github.com/intel/QATzip.git" target="_blank" rel="noopener">qatzip_github代码仓库</a></p><p>简单的压缩代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_QAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpa_dc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qatzip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qatzip_internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qz_utils.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> QzSessionParams_T g_params_th;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qzipCompress</span><span class="params">(Bytef *data, uLong ndata, Bytef *zdata, uLong *nzdata, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_QAT</span></span><br><span class="line">    QzSession_T session;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    rc = qzInit(&amp;session, g_params_th.sw_backup);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK &amp;&amp; rc != QZ_DUPLICATE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzInit failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = qzSetupSession(&amp;session, &amp;g_params_th);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK &amp;&amp; rc != QZ_NO_INST_ATTACH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzSetupSession failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = qzCompress(&amp;session, data, (<span class="keyword">uint32_t</span> *)&amp;ndata, zdata, (<span class="keyword">uint32_t</span> *)nzdata, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzCompress failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qzTeardownSession(&amp;session);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> gzCompress(data, ndata, zdata, nzdata, level);</span><br><span class="line"><span class="meta">#e</span></span><br></pre></td></tr></table></figure><h2 id="igzip库"><a href="#igzip库" class="headerlink" title="igzip库"></a>igzip库</h2><p>intel工程师使用指令集优化zlib,针对genomic data比如<strong>bam sam</strong>数据,在几乎不降低压缩率的情况下,速度提升约4倍<br><a href="https://github.com/intel/isa-l.git" target="_blank" rel="noopener">igzip_github代码仓库</a><br>igzip的代码和isa-l代码仓库在一起</p><p>igzip使用代码示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"igzip_lib.h"</span></span></span><br><span class="line"><span class="keyword">int</span> level_size_buf[<span class="number">10</span>] = &#123;</span><br><span class="line">#ifdef ISAL_DEF_LVL0_DEFAULT</span><br><span class="line">ISAL_DEF_LVL0_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL1_DEFAULT</span><br><span class="line">ISAL_DEF_LVL1_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL2_DEFAULT</span><br><span class="line">ISAL_DEF_LVL2_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL3_DEFAULT</span><br><span class="line">ISAL_DEF_LVL3_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL4_DEFAULT</span><br><span class="line">ISAL_DEF_LVL4_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL5_DEFAULT</span><br><span class="line">ISAL_DEF_LVL5_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL6_DEFAULT</span><br><span class="line">ISAL_DEF_LVL6_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL7_DEFAULT</span><br><span class="line">ISAL_DEF_LVL7_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL8_DEFAULT</span><br><span class="line">ISAL_DEF_LVL8_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL9_DEFAULT</span><br><span class="line">ISAL_DEF_LVL9_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> mylong;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">igzipCompress</span><span class="params">(mychar* source, mylong source_len, mychar* dest, mylong* dest_len, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">isal_zstream</span> <span class="title">stream</span>;</span> <span class="comment">/* Holds stream information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">isal_gzip_header</span> <span class="title">gz_hdr</span>;</span></span><br><span class="line"></span><br><span class="line">isal_gzip_header_init(&amp;gz_hdr); <span class="comment">/* Set gzip header default values */</span></span><br><span class="line"></span><br><span class="line">isal_deflate_init(&amp;stream); <span class="comment">/* Initialize compression stream data structure */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level_size = level_size_buf[level];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * level_buf = <span class="literal">NULL</span>;</span><br><span class="line">level_buf = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(level_size);</span><br><span class="line"></span><br><span class="line">stream.avail_in = <span class="number">0</span>; <span class="comment">// Number of bytes available at next_in.</span></span><br><span class="line">stream.flush = NO_FLUSH;    <span class="comment">// Flush type can be NO_FLUSH,SYNC_FLUSH or FULL_FLUSH.</span></span><br><span class="line">stream.level = level;   <span class="comment">// Compression level to use.</span></span><br><span class="line">stream.level_buf = level_buf; <span class="comment">// User allocated buffer required for different compression levels.</span></span><br><span class="line">stream.level_buf_size = level_size;   <span class="comment">// Size of level_buf.</span></span><br><span class="line">stream.gzip_flag = IGZIP_GZIP_NO_HDR;   <span class="comment">// Indicate if gzip compression is to be performed.</span></span><br><span class="line">stream.next_out = dest; <span class="comment">// Next output byte.</span></span><br><span class="line">stream.avail_out = *dest_len;   <span class="comment">// Number of bytes avaliable at next_out.</span></span><br><span class="line"></span><br><span class="line">isal_write_gzip_header(&amp;stream, &amp;gz_hdr);   <span class="comment">/* Write gzip header to output stream. */</span></span><br><span class="line"></span><br><span class="line">stream.next_in = source;</span><br><span class="line">stream.avail_in = source_len;</span><br><span class="line">stream.end_of_stream = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = isal_deflate(&amp;stream);</span><br><span class="line"><span class="keyword">if</span> (ret != ISAL_DECOMP_OK) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"igzip: Error encountered while compressing file\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (level_buf != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">free</span>(level_buf);</span><br><span class="line">*dest_len = stream.next_out - dest;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bgzip库及多线程解压缩"><a href="#bgzip库及多线程解压缩" class="headerlink" title="bgzip库及多线程解压缩"></a>bgzip库及多线程解压缩</h2><p>bgzip:Block compression/decompression utility<br>用于bam/sam文件的格式,核心是将压缩数据分块(64KB),从而通过索引可以快速查询数据  </p><p>注:bam/sam文件是高通量测序的标准格式文件,存储内容为fastq文件与参考基因组reference进行mapping之后的数据;其中sam为文本格式,bam为二进制格式,两者可以通过<em>samtools</em>工具相互转换;bam文件可以通过建立index,快速定位数据位置,从而加速访问</p><p>考虑这样一种情况,有一千个block的数据需要压缩并存放在一个文件中,这个文件可能很大,几百GB;假如我只想要分析某几个block的数据,传统的压缩方式需要将整个文件全部解压之后才能获取想要的数据,效率很低</p><p>而通过自定义压缩block的head信息,使用其中的<strong>extra filed</strong> 和 <strong>comment</strong> 字段就可以实现index功能,步骤如下:</p><ol><li><p>压缩前,首先添加字段:comment添加block的ID,extra field添加压缩前和后的bytes大小;以zlib压缩举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> EXTRA_LEN = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> EXTRA_BUF_LEN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> SI1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> SI2 = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">gz_header header;</span><br><span class="line"><span class="comment">// 添加comment信息,如指定当前block的ID,如1,2,3等</span></span><br><span class="line"><span class="comment">// 用于后续快速获取想要的block数据</span></span><br><span class="line">header.comment = (Bytef *)&amp;comment[<span class="number">0</span>];</span><br><span class="line">header.comm_max = comment.size() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 按照标准格式指定extra field的长度信息</span></span><br><span class="line">header.extra_len = EXTRA_LEN;</span><br><span class="line">header.extra_max = EXTRA_BUF_LEN;</span><br><span class="line"><span class="keyword">uint8_t</span> extra_buf[EXTRA_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// SI1 SI2为自定义字段,用来标识我们自定义的头文件格式</span></span><br><span class="line">extra_buf[<span class="number">0</span>] = SI1;</span><br><span class="line">extra_buf[<span class="number">1</span>] = SI2;</span><br><span class="line">extra_buf[<span class="number">2</span>] = EXTRA_BUF_LEN;</span><br><span class="line">extra_buf[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">header.extra = extra_buf;</span><br><span class="line">err = deflateSetHeader(&amp;c_stream, &amp;header);</span><br></pre></td></tr></table></figure></li><li><p>压缩后,更新extra filed中压缩前后数据长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*nzdata = c_stream.total_out;</span><br><span class="line"></span><br><span class="line">mylong dest_size = *nzdata; <span class="comment">// 压缩后大小,必须压缩完之后才能获取</span></span><br><span class="line">mylong raw_size = ndata; <span class="comment">// 压缩前大小,是输入参数,我们是知道的</span></span><br><span class="line"><span class="comment">// 将两个长度按顺序写入字节流</span></span><br><span class="line"><span class="built_in">memcpy</span>(zdata + <span class="number">16</span>, &amp;dest_size, <span class="keyword">sizeof</span>(dest_size));</span><br><span class="line"><span class="built_in">memcpy</span>(zdata + <span class="number">24</span>, &amp;raw_size, <span class="keyword">sizeof</span>(raw_size));</span><br></pre></td></tr></table></figure></li><li><p>解压缩的时候,首先找到第一个block,读入头信息,获取当前block的标识ID,如果是想要的数据,则通过extra field获取数据长度,按照长度直接读取即可,然后跳到下一个block<br>因为对于无用的block数据,我们只要解析头信息,并<strong>根据长度进行偏移</strong>即可,所以遍历速度会很快<br>然后还可以通过<strong>多线程</strong>进行解压缩,主线程进行block的遍历,如果遇到目标数据,则从线程池中拿一个线程处理当前block<br>如果不需要解压缩,只是从1000个block中采样10个block进行后续的快速分析,则直接将10个block的二进制数据连续输出到磁盘文件即可,多个block可以直接cat到一起而不影响解压缩</p></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/zhuyf87/archive/2013/02/21/2920522.html" target="_blank" rel="noopener">zlib压缩数据</a><br><a href="http://zlib.net/" target="_blank" rel="noopener">zlib官网</a><br><a href="https://software.intel.com/en-us/articles/igzip-a-high-performance-deflate-compressor-with-optimizations-for-genomic-data" target="_blank" rel="noopener">High Performance DEFLATE Compression with Optimizations for Genomic Data Sets</a><br><a href="http://www.zlib.org/rfc-gzip.html" target="_blank" rel="noopener">GZIP file format specification version 4.3</a><br><a href="https://zlib.net/manual.html" target="_blank" rel="noopener">GZIP文件格式简介</a><br><a href="http://www.htslib.org/doc/bgzip.html" target="_blank" rel="noopener">zlib 1.2.11 Manual</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结工作中使用过的数据压缩方法,主要有zlib,qatzip,igzip等&lt;br&gt;最后还进行了针对大规模数据多线程解压缩加速的分析&lt;/p&gt;
&lt;h2 id=&quot;zlib库&quot;&gt;&lt;a href=&quot;#zlib库&quot; class=&quot;headerlink&quot; title=&quot;zlib库&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="压缩 zlib igzip" scheme="http://yoursite.com/tags/%E5%8E%8B%E7%BC%A9-zlib-igzip/"/>
    
  </entry>
  
  <entry>
    <title>在cuda中使用哈希表</title>
    <link href="http://yoursite.com/2020/03/15/use-hash-in-cuda/"/>
    <id>http://yoursite.com/2020/03/15/use-hash-in-cuda/</id>
    <published>2020-03-15T12:08:38.000Z</published>
    <updated>2020-03-15T13:04:19.851Z</updated>
    
    <content type="html"><![CDATA[<p>关于在cuda中使用哈希表的一些经验总结</p><h2 id="cuda中哈希方法"><a href="#cuda中哈希方法" class="headerlink" title="cuda中哈希方法"></a>cuda中哈希方法</h2><p>目前已知的在cuda中使用哈希的方法:</p><ol><li><p><strong>数组</strong><br>适用于较小的数据规模,如键的范围是int,或者能转化为整型,值类型最长为long等</p></li><li><p><strong>cudpp</strong><br>可接受的键值范围均为32bit,相比数组好处是占用内存小,不用存储无用数据<br>其内部使用布谷鸟过滤,核心思想是多个hash算法生成多个映射值,如果有一个位置是空的,就将元素放入,否则踢走其中一个,被踢走的再去踢别人,依次类推<br>缺点是无法动态插入,即必须把键值对先准备好;主要用来查询<br><a href="https://github.com/cudpp/cudpp" target="_blank" rel="noopener">cudpp_github</a></p></li><li><p><strong>huge-CTR</strong><br>这是英伟达开发的一个点击率推荐系统的库,其中实现了哈希功能<br>优点是官方文档写了支持动态插入<br><a href="https://github.com/NVIDIA/HugeCTR" target="_blank" rel="noopener">huge-CTR_github</a></p></li></ol><h2 id="cudpp-hash使用"><a href="#cudpp-hash使用" class="headerlink" title="cudpp hash使用"></a>cudpp hash使用</h2><p>使用步骤:</p><ol><li><p>获取GPU卡信息<br>这也是任何cuda程序的第一步,检查有没有卡,以及卡的计算能力等;使用<code>cudaGetDeviceCount() cudaGetDeviceProperties()</code>等API来获取信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceCount;</span><br><span class="line">cudaGetDeviceCount(&amp;deviceCount);</span><br><span class="line"><span class="keyword">if</span> (deviceCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error (main): no devices supporting CUDA.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dev = <span class="number">0</span>;</span><br><span class="line">cudaSetDevice(dev);</span><br><span class="line">cudaDeviceProp prop;</span><br><span class="line"><span class="keyword">if</span> (!quiet &amp;&amp; cudaGetDeviceProperties(&amp;prop, dev) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using device %d:\n"</span>, dev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s; global mem: %uB; compute v%d.%d; clock: %d kHz\n"</span>,</span><br><span class="line">           prop.name, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)prop.totalGlobalMem, (<span class="keyword">int</span>)prop.major,</span><br><span class="line">           (<span class="keyword">int</span>)prop.minor, (<span class="keyword">int</span>)prop.clockRate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (prop.major &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: CUDPP hash tables are only supported on "</span></span><br><span class="line">            <span class="string">"devices with compute\n  capability 2.0 or greater; "</span></span><br><span class="line">            <span class="string">"exiting.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<em>CUDPP Handle</em><br>CUDPPHandle 在每个cuda上下文都要建立一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CUDPPHandle theCudpp;</span><br><span class="line">CUDPPResult result = cudppCreate(&amp;theCudpp);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error initializing CUDPP Library.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>准备数据<br> 准备两个unsigned int* 数组, 分别存放keys和values<br> 也可以从一个std::unordered_map获取数据<br> 将keys和values从host拷贝到device</p></li><li><p>创建<em>CUDPPHandle</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CUDPPHashTableConfig config;</span><br><span class="line">config.type = CUDPP_BASIC_HASH_TABLE;</span><br><span class="line">config.kInputSize = kInputSize;</span><br><span class="line">config.space_usage = space_usage;<span class="comment">// 测试值有 1.05f, 1.15f, 1.25f, 1.5f, 2.0f</span></span><br><span class="line">CUDPPHandle hash_table_handle;</span><br><span class="line">CUDPPResult result;</span><br><span class="line">result = cudppHashTable(theCudpp, &amp;hash_table_handle, &amp;config);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashTable call in"</span></span><br><span class="line">            <span class="string">"testHashTable (make sure your device is at"</span></span><br><span class="line">            <span class="string">"least compute version 2.0\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = cudppHashInsert(hash_table_handle, d_test_keys, d_test_vals, kInputSize);</span><br><span class="line">cudaThreadSynchronize();</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashInsert call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用哈希表查询数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = cudppHashRetrieve(hash_table_handle, d_test_keys, d_test_vals, kInputSize);</span><br><span class="line">cudaThreadSynchronize();</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashRetrieve call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证数据<br>将查询的结果由GPU内存拷贝回CPU内存,进行数据的验证</p></li><li><p>释放资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = cudppDestroyHashTable(theCudpp, hash_table_handle);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppDestroyHashTable call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">result = cudppDestroy(theCudpp);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error shutting down CUDPP Library.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="问题和改进"><a href="#问题和改进" class="headerlink" title="问题和改进"></a>问题和改进</h2><h3 id="cudpp内存泄漏问题"><a href="#cudpp内存泄漏问题" class="headerlink" title="cudpp内存泄漏问题"></a>cudpp内存泄漏问题</h3><p>cudpp在更新的cuda版本如cuda10,更新的显卡架构如TitanV下出现内存泄漏问题<br>情况就是只要使用cudpp的lib,代码经过第一个cuda API调用之后就会卡死,内存不断增长,直到内存爆掉<br>经过测试,我发现是计算能力配置问题,新的显卡架构支持更高的计算能力,只要在编译选项中增加<strong>compute_60;compute_70</strong>即可解决问题<br>详见<a href="https://github.com/cudpp/cudpp/issues/187" target="_blank" rel="noopener">cudpp_issues_187</a></p><h3 id="扩展cudpp哈希表"><a href="#扩展cudpp哈希表" class="headerlink" title="扩展cudpp哈希表"></a>扩展cudpp哈希表</h3><blockquote><p>修改CUDPP库中哈希功能支持更长的键类型.</p></blockquote><blockquote><p>原库支持32bit键值对,将其编码在64bit的long long类型中;我实际工作中需要对碱基序列进行哈希查找,每一个碱基可能有ACGTN五种类型,最开始只处理单barcode是10bp,所以有5^10(9765625)种可能序列,不到10M数据,在cuda中使用数组就可以了;后来需要处理双barcode,20bp,有5^20(95367431640625)种可能序列,需要约95T数据,数组显然不够,只能用哈希,因此将键类型从32bit扩展到48bit,可以支持5^20的键,剩下16bit存储值,依然编码到64bit的long long类型,达到最小改动满足需求的目的.</p></blockquote><p><a href="https://github.com/tigeroses/cudpp" target="_blank" rel="noopener">仓库地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于在cuda中使用哈希表的一些经验总结&lt;/p&gt;
&lt;h2 id=&quot;cuda中哈希方法&quot;&gt;&lt;a href=&quot;#cuda中哈希方法&quot; class=&quot;headerlink&quot; title=&quot;cuda中哈希方法&quot;&gt;&lt;/a&gt;cuda中哈希方法&lt;/h2&gt;&lt;p&gt;目前已知的在cuda中使用哈
      
    
    </summary>
    
    
    
      <category term="cuda hash cudpp" scheme="http://yoursite.com/tags/cuda-hash-cudpp/"/>
    
  </entry>
  
</feed>
